{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pr\u00e1ctica 2.1 \u2013 Instalaci\u00f3n y configuraci\u00f3n de servidor web Nginx","text":""},{"location":"#instalacion-servidor-web-nginx","title":"Instalaci\u00f3n servidor web Nginx","text":"<p>Para instalar el servidor Nginx en nuestra Debian, primero actualizamos los repositorios y despu\u00e9s instalamos el paquete correspondiente:</p> <p></p> <p>Comprobamos que Nginx se ha instalado y que est\u00e1 funcionando correctamente:</p> <p></p>"},{"location":"#creacion-de-la-carpeta-del-sitio-web","title":"Creaci\u00f3n de la carpeta del sitio web","text":"<p>Una vez hecho esto vamos a crear la carpeta de nuestro sitio web o dominio:</p> <p></p> <p>Dentro de esa carpeta <code>html</code>, deb\u00e9is clonar el siguiente repositorio:</p> <p>https://github.com/cloudacademy/static-website-example</p> <p></p> <p>Adem\u00e1s, haremos que el propietario de esta carpeta y todo lo que haya dentro sea el usuario <code>www-data</code>, t\u00edpicamente el usuario del servicio web.</p> <p></p> <p>Y le daremos los permisos adecuados para que no nos d\u00e9 un error de acceso no autorizado al entrar en el sitio web:</p> <p></p> <p>Para comprobar que el servidor est\u00e1 funcionando y sirviendo p\u00e1ginas correctamente, pod\u00e9is acceder desde vuestro cliente a:</p> <p><code>http://IP-maq-virtual</code></p> <p></p> <p>En Nginx hay dos rutas importantes. La primera de ellas es <code>sites-available</code>, que contiene los archivos de configuraci\u00f3n de los hosts virtuales o bloques disponibles en el servidor. Es decir, cada uno de los sitios webs que alberga el servidor. La otra es <code>sites-enabled</code>, que contiene los archivos de configuraci\u00f3n de los sitios habilitados, es decir, los que funcionan en ese momento.</p> <p>Dentro de <code>sites-available</code> hay un archivo de configuraci\u00f3n por defecto (<code>default</code>), que es la p\u00e1gina que se muestra si accedemos al servidor sin indicar ning\u00fan sitio web o cuando el sitio web no es encontrado en el servidor (debido a una mala configuraci\u00f3n, por ejemplo). Esta es la p\u00e1gina que nos ha aparecido en el apartado anterior.</p> <p>Para que Nginx presente el contenido de nuestra web, es necesario crear un bloque de servidor con las directivas correctas. En vez de modificar el archivo de configuraci\u00f3n predeterminado directamente, crearemos uno nuevo en <code>/etc/nginx/sites-available/nombre_web</code>:</p> <p></p> <p>Y el contenido de este nuevo archivo es:</p> <p></p> <p>Aqu\u00ed la directiva <code>root</code> debe ir seguida de la ruta absoluta donde se encuentre el archivo <code>index.html</code> de nuestra p\u00e1gina web, que se encuentra entre todos los que hab\u00e9is descomprimido.</p> <p>Y crearemos un archivo simb\u00f3lico entre este archivo y el de sitios que est\u00e1n habilitados, para que se d\u00e9 de alta autom\u00e1ticamente.</p> <p> Y reiniciamos el servidor para aplicar la configuraci\u00f3n:</p> <p></p>"},{"location":"#comprobaciones","title":"Comprobaciones","text":""},{"location":"#comprobacion-del-correcto-funcionamiento","title":"Comprobaci\u00f3n del correcto funcionamiento","text":"<p>Como a\u00fan no poseemos un servidor DNS que traduzca los nombres a IPs, debemos hacerlo de forma manual. Vamos a editar el archivo <code>/etc/hosts</code> de nuestra m\u00e1quina anfitriona para que asocie la IP de la m\u00e1quina virtual a nuestro <code>server_name</code>.</p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code></p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></p> <p>En mi caso usare windows</p> <p></p> <p>Y deberemos a\u00f1adirle la l\u00ednea:</p> <p><code>192.168.X.X nombre_web</code></p> <p></p> <p>Donde deb\u00e9is sustituir la IP por la que tenga vuestra m\u00e1quina virtual.</p>"},{"location":"#comprobar-registros-del-servidor","title":"Comprobar registros del servidor","text":"<p>Comprobad que las peticiones se est\u00e1n registrando correctamente en los archivos de logs, tanto las correctas como las err\u00f3neas:</p> <ul> <li><code>/var/log/nginx/access.log</code>: cada solicitud a su servidor web se registra en este archivo de registro, a menos que Nginx est\u00e9 configurado para hacer algo diferente.</li> <li><code>/var/log/nginx/error.log</code>: cualquier error de Nginx se asentar\u00e1 en este registro.</li> </ul> <p>Aqui se muestra el contenido que contine mi <code>/var/log/nginx/access.log</code></p> <p></p> <p>Si queremos tener varios dominios o sitios web en el mismo servidor Nginx (es decir, que tendr\u00e1n la misma IP), debemos repetir todo el proceso anterior con el nuevo nombre de dominio que queramos configurar.</p>"},{"location":"#configurar-servidor-sftp-en-debian","title":"Configurar servidor SFTP en Debian","text":"<p>En primer lugar, lo instalaremos desde los repositorios:</p> <pre><code>sudo apt-get update\nsudo apt-get install vsftpd\n\n</code></pre> <p></p> <p>Ahora vamos a crear una carpeta en nuestro home en Debian:</p> <pre><code>mkdir /home/nombre_usuario/ftp\n</code></pre> <p></p> <p>En la configuraci\u00f3n de vsftpd indicaremos que este ser\u00e1 el directorio al cual vsftpd se cambia despu\u00e9s de conectarse el usuario.</p> <p>Ahora vamos a crear los certificados de seguridad necesarios para aportar la capa de cifrado a nuestra conexi\u00f3n (algo parecido a HTTPS):</p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem\n</code></pre> <p></p> <p>Y una vez realizados estos pasos, procedemos a realizar la configuraci\u00f3n de vsftpd propiamente dicha. Se trata, con el editor de texto que m\u00e1s os guste, de editar el archivo de configuraci\u00f3n de este servicio, por ejemplo con nano:</p> <pre><code>sudo nano /etc/vsftpd.conf\n</code></pre> <p></p> <p>En primer lugar, buscaremos las siguientes l\u00edneas del archivo y las eliminaremos por completo:</p> <pre><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n</code></pre> <p></p> <p>Tras ello, a\u00f1adiremos estas l\u00edneas en su lugar:</p> <pre><code>rsa_cert_file=/etc/ssl/private/vsftpd.pem\nrsa_private_key_file=/etc/ssl/private/vsftpd.pem\nssl_enable=YES\nallow_anon_ssl=NO\nforce_local_data_ssl=YES\nforce_local_logins_ssl=YES\nssl_tlsv1=YES\nssl_sslv2=NO\nssl_sslv3=NO\nrequire_ssl_reuse=NO\nssl_ciphers=HIGH\n\nlocal_root=/home/nombre_usuario/ftp\n</code></pre> <p></p> <p>Y, tras guardar los cambios, reiniciamos el servicio para que coja la nueva configuraci\u00f3n:</p> <pre><code>sudo systemctl restart --now vsftpd\n</code></pre> <p></p> <p>Tras acabar esta configuraci\u00f3n, ya podremos acceder a nuestro servidor mediante un cliente FTP adecuado, como por ejemplo Filezilla de dos formas, a saber:</p> <ol> <li>Mediante el puerto por defecto del protocolo inseguro FTP, el 21, pero utilizando certificados que cifran el intercambio de datos convirti\u00e9ndolo as\u00ed en seguro.</li> <li>Haciendo uso del protocolo SFTP, dedicado al intercambio de datos mediante una conexi\u00f3n similar a SSH, utilizando de hecho el puerto 22.</li> </ol> <p></p> <p></p> <p></p> <p>Recordemos que debemos tener nuestro sitio web en la carpeta <code>/var/www</code> y darle los permisos adecuados, de forma similar a c\u00f3mo hemos hecho con el otro sitio web.</p> <p>El comando que nos permite descomprimir un .zip en un directorio concreto es:</p> <pre><code>unzip archivo.zip -d /nombre/directorio\n</code></pre> <p>Si no tuvierais <code>unzip</code> instalado, lo instal\u00e1is:</p> <pre><code>sudo apt-get update &amp;&amp; sudo apt-get install unzip\n</code></pre>"},{"location":"#para-configurar-https-en-tu-servidor-web-y-redirigir-automaticamente-todas-las-solicitudes-http-a-https","title":"Para configurar HTTPS en tu servidor web y redirigir autom\u00e1ticamente todas las solicitudes HTTP a HTTPS:","text":"<ul> <li>Generar Certificados SSL Autofirmados   Para generar certificados SSL autofirmados, usa el siguiente comando:</li> </ul> <p><code>bash   sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</code></p> <p></p> <ul> <li>Configurar Nginx para Usar el Certificado SSL   Edita el archivo de configuraci\u00f3n del sitio web en Nginx. Esto podr\u00eda estar en <code>/etc/nginx/sites-available/nombre_web</code> o <code>/etc/nginx/conf.d/nombre_web.conf</code> dependiendo de tu configuraci\u00f3n.</li> </ul> <p><code>bash   sudo nano /etc/nginx/sites-available/nombre_web</code></p> <p>Agrega o modifica las secciones de configuraci\u00f3n como sigue:</p> <p></p> <p></p> <ul> <li>Revisar la Configuraci\u00f3n de Nginx   Despu\u00e9s de hacer los cambios, revisa la configuraci\u00f3n de Nginx para asegurarte de que no haya errores:</li> </ul> <p><code>bash   sudo nginx -t</code></p> <p>Si la configuraci\u00f3n es correcta, ver\u00e1s un mensaje de \u00e9xito.</p> <ul> <li>Reiniciar Nginx   Reinicia el servidor Nginx para aplicar los cambios:</li> </ul> <p><code>bash   sudo systemctl restart nginx</code></p> <p></p> <ul> <li>Comprobar la Redirecci\u00f3n y HTTPS   Abre tu navegador y visita <code>http://servidor1</code> (o la direcci\u00f3n IP o dominio que est\u00e9s utilizando). Deber\u00edas ser redirigido autom\u00e1ticamente a <code>https://servidor1</code>.   Comprueba que el certificado se carga correctamente y que el sitio est\u00e1 utilizando HTTPS.</li> </ul> <p></p>"},{"location":"Practica10/","title":"GITHUB I","text":""},{"location":"Practica10/#repositorio-deaw","title":"Repositorio DEAW","text":"<ol> <li>Crear un repositorio en vuestro GitHub llamado DEAW.</li> <li>Clonar vuestro repositorio en local.</li> </ol>"},{"location":"Practica10/#readme","title":"README","text":"<ol> <li>Crear (si no lo hab\u00e9is creado ya) en vuestro repositorio local un documento <code>README.md</code>.</li> <li>Escribir un peque\u00f1o texto en este README a prop\u00f3sito del repositorio y el m\u00f3dulo para el que se utilizar\u00e1.</li> </ol>"},{"location":"Practica10/#commit-inicial-push-inicial","title":"Commit inicial, Push inicial","text":"<ol> <li>Realizar un commit inicial con el comentario <code>Comenzamos con los ejercicios de Git</code>.</li> <li>Subir los cambios al repositorio remoto.</li> </ol>"},{"location":"Practica10/#ignorar-archivos","title":"Ignorar archivos","text":"<ol> <li>Crear en el repositorio local un fichero llamado <code>privado.txt</code>.</li> <li>Crear en el repositorio local una carpeta llamada <code>privada</code>.</li> <li>Realizar los cambios oportunos para que tanto el archivo como la carpeta sean ignorados por git.</li> </ol>"},{"location":"Practica10/#anadir-fichero-1txt","title":"A\u00f1adir fichero <code>1.txt</code>","text":"<ol> <li>A\u00f1adir fichero <code>1.txt</code> al repositorio local.</li> </ol>"},{"location":"Practica10/#crear-el-tag-v01","title":"Crear el tag <code>v0.1</code>","text":"<ol> <li>Crear un tag <code>v0.1</code>.</li> <li>Subir los cambios al repositorio remoto.</li> </ol>"},{"location":"Practica10/#crear-una-rama-v02","title":"Crear una rama <code>v0.2</code>","text":"<ol> <li>Crear una rama <code>v0.2</code>.</li> <li>Posiciona tu carpeta de trabajo en esta rama.</li> </ol>"},{"location":"Practica10/#anadir-fichero-2txt","title":"A\u00f1adir fichero <code>2.txt</code>","text":"<ol> <li>A\u00f1adir un fichero <code>2.txt</code> en la rama <code>v0.2</code>.</li> </ol>"},{"location":"Practica10/#crear-rama-remota-v02","title":"Crear rama remota <code>v0.2</code>","text":"<ol> <li>Subir los cambios al repositorio remoto.</li> </ol>"},{"location":"Practica10/#merge-directo","title":"Merge directo","text":"<ol> <li>Posicionarse en la rama <code>master</code>.</li> <li>Hacer un merge de la rama <code>v0.2</code> en la rama <code>master</code>.</li> </ol>"},{"location":"Practica10/#merge-con-conflicto","title":"Merge con conflicto","text":"<ol> <li>En la rama <code>master</code> poner <code>Hola</code> en el fichero <code>1.txt</code> y hacer commit.</li> <li>Posicionarse en la rama <code>v0.2</code> y poner <code>Adios</code> en el fichero <code>1.txt</code> y hacer commit.</li> <li>Posicionarse de nuevo en la rama <code>master</code> y hacer un merge con la rama <code>v0.2</code>.</li> </ol>"},{"location":"Practica10/#listado-de-ramas","title":"Listado de ramas","text":"<ol> <li>Listar las ramas con merge y las ramas sin merge.</li> </ol>"},{"location":"Practica10/#arreglar-conflicto","title":"Arreglar conflicto","text":"<ol> <li>Arreglar el conflicto anterior y hacer un commit.</li> </ol>"},{"location":"Practica10/#borrar-rama","title":"Borrar rama","text":"<ol> <li>Crear un tag <code>v0.2</code>.</li> <li>Borrar la rama <code>v0.2</code>.</li> </ol>"},{"location":"Practica10/#listado-de-cambios","title":"Listado de cambios","text":"<ol> <li>Listar los distintos commits con sus ramas y sus tags.</li> </ol>"},{"location":"Practica10/#github-ii","title":"GITHUB II","text":""},{"location":"Practica10/#ejercicios-de-creacion-y-actualizacion-de-repositorios","title":"Ejercicios de creaci\u00f3n y actualizaci\u00f3n de repositorios","text":""},{"location":"Practica10/#ejercicio-1","title":"Ejercicio 1","text":"<p>Configurar Git definiendo el nombre del usuario, el correo electr\u00f3nico y activar el coloreado de la salida.</p> <p>Mostrar la configuraci\u00f3n final.</p> <p></p>"},{"location":"Practica10/#ejercicio-2","title":"Ejercicio 2","text":"<p>Crear un repositorio nuevo con el nombre libro y mostrar su contenido.</p> <p></p>"},{"location":"Practica10/#ejercicio-3","title":"Ejercicio 3","text":"<p>Comprobar el estado del repositorio.</p> <p>Crear un fichero <code>indice.txt</code> con el siguiente contenido:</p> <pre><code>Cap\u00edtulo 1: Introducci\u00f3n a Git\nCap\u00edtulo 2: Flujo de trabajo b\u00e1sico\nCap\u00edtulo 3: Repositorios remotos\n</code></pre> <p>Comprobar de nuevo el estado del repositorio.</p> <p>A\u00f1adir el fichero a la zona de intercambio temporal.</p> <p>Volver a comprobar una vez m\u00e1s el estado del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicio-4","title":"Ejercicio 4","text":"<p>Realizar un commit de los \u00faltimos cambios con el mensaje \u201cA\u00f1adido \u00edndice del libro.\u201d y ver el estado del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicio-5","title":"Ejercicio 5","text":"<p>Cambiar el fichero <code>indice.txt</code> para que contenga lo siguiente:</p> <pre><code>Cap\u00edtulo 1: Introducci\u00f3n a Git\nCap\u00edtulo 2: Flujo de trabajo b\u00e1sico\nCap\u00edtulo 3: Gesti\u00f3n de ramas\nCap\u00edtulo 4: Repositorios remotos\n</code></pre> <p>Mostrar los cambios con respecto a la \u00faltima versi\u00f3n guardada en el repositorio.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas\u201d.</p> <p></p>"},{"location":"Practica10/#ejercicio-6","title":"Ejercicio 6","text":"<p>Mostrar los cambios de la \u00faltima versi\u00f3n del repositorio con respecto a la anterior.</p> <p>Cambiar el mensaje del \u00faltimo commit por \u201cA\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas al \u00edndice.\u201d</p> <p>Volver a mostrar los \u00faltimos cambios del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicios-de-manejo-del-historial-de-cambios","title":"Ejercicios de manejo del historial de cambios","text":""},{"location":"Practica10/#ejercicio-1_1","title":"Ejercicio 1","text":"<p>Mostrar el historial de cambios del repositorio.</p> <p>Crear la carpeta <code>capitulos</code> y crear dentro de ella el fichero <code>capitulo1.txt</code> con el siguiente texto.</p> <pre><code>Git es un sistema de control de versiones ideado por Linus Torvalds.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 1.\u201d Volver a mostrar el historial de cambios del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicio-2_1","title":"Ejercicio 2","text":"<p>Crear el fichero <code>capitulo2.txt</code> en la carpeta <code>capitulos</code> con el siguiente texto.</p> <pre><code>El flujo de trabajo b\u00e1sico con Git consiste en: \n1- Hacer cambios en el repositorio. \n2- A\u00f1adir los cambios a la zona de intercambio temporal. \n3- Hacer un commit de los cambios.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 2.\u201d</p> <p>Mostrar las diferencias entre la \u00faltima versi\u00f3n y dos versiones anteriores.</p> <p></p>"},{"location":"Practica10/#ejercicio-3_1","title":"Ejercicio 3","text":"<p>Crear el fichero <code>capitulo3.txt</code> en la carpeta <code>capitulos</code> con el siguiente texto.</p> <pre><code>Git permite la creaci\u00f3n de ramas lo que permite tener distintas versiones del mismo proyecto y trabajar de manera simultanea en ellas.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 3.\u201d</p> <p>Mostrar las diferencias entre la primera y la \u00faltima versi\u00f3n del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicio-4_1","title":"Ejercicio 4","text":"<p>A\u00f1adir al final del fichero <code>indice.txt</code> la siguiente l\u00ednea:</p> <pre><code>Cap\u00edtulo 5: Conceptos avanzados\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit de los cambios con el mensaje \u201cA\u00f1adido cap\u00edtulo 5 al \u00edndice.\u201d</p> <p>Mostrar qui\u00e9n ha hecho cambios sobre el fichero <code>indice.txt</code>. </p>"},{"location":"Practica10/#ejercicios-de-deshacer-cambios","title":"Ejercicios de deshacer cambios","text":""},{"location":"Practica10/#ejercicio-1_2","title":"Ejercicio 1","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p>Comprobar el estado del repositorio.</p> <p>Deshacer los cambios realizados en el fichero <code>indice.txt</code> para volver a la versi\u00f3n anterior del fichero.</p> <p>Volver a comprobar el estado del repositorio. </p>"},{"location":"Practica10/#ejercicio-2_2","title":"Ejercicio 2","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Deshacer los cambios realizados en el fichero <code>indice.txt</code> para volver a la versi\u00f3n anterior del fichero.</p> <p>Volver a comprobar el estado del repositorio. </p>"},{"location":"Practica10/#ejercicio-3_2","title":"Ejercicio 3","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p>Eliminar el fichero <code>capitulos/capitulo3.txt</code>.</p> <p>A\u00f1adir un fichero nuevo <code>capitulos/capitulo4.txt</code> vac\u00edo.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Comprobar de nuevo el estado del repositorio.</p> <p>Deshacer los cambios realizados para volver a la versi\u00f3n del repositorio.</p> <p>Volver a comprobar el estado del repositorio.</p> <p> </p>"},{"location":"Practica10/#ejercicio-4_2","title":"Ejercicio 4","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p>Eliminar el fichero <code>capitulos/capitulo3.txt</code>.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cBorrado accidental.\u201d</p> <p>Comprobar el historial del repositorio.</p> <p>Deshacer el \u00faltimo commit pero mantener los cambios anteriores en el directorio de trabajo y la zona de intercambio temporal.</p> <p>Comprobar el historial y el estado del repositorio.</p> <p>Volver a hacer el commit con el mismo mensaje de antes.</p> <p>Deshacer el \u00faltimo commit y los cambios anteriores del directorio de trabajo volviendo a la versi\u00f3n anterior del repositorio.</p> <p>Comprobar de nuevo el historial y el estado del repositorio.  </p>"},{"location":"Practica10/#ejercicios-de-gestion-de-ramas","title":"Ejercicios de gesti\u00f3n de ramas","text":""},{"location":"Practica10/#ejercicio-1_3","title":"Ejercicio 1","text":"<p>Crear una nueva rama <code>bibliografia</code> y mostrar las ramas del repositorio.</p> <p></p>"},{"location":"Practica10/#ejercicio-2_3","title":"Ejercicio 2","text":"<p>Crear el fichero <code>capitulos/capitulo4.txt</code> y a\u00f1adir el texto siguiente:</p> <pre><code>En este cap\u00edtulo veremos c\u00f3mo usar GitHub para alojar repositorios en remoto.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adido cap\u00edtulo 4.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"Practica10/#ejercicio-3_3","title":"Ejercicio 3","text":"<p>Cambiar a la rama <code>bibliografia</code>.</p> <p>Crear el fichero <code>bibliografia.txt</code> y a\u00f1adir la siguiente referencia:</p> <pre><code>Chacon, S. and Straub, B. Pro Git. Apress.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adida primera referencia bibliogr\u00e1fica.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"Practica10/#ejercicio-4_3","title":"Ejercicio 4","text":"<p>Fusionar la rama <code>bibliografia</code> con la rama <code>master</code>.</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p>Eliminar la rama <code>bibliografia</code>.</p> <p>Mostrar de nuevo la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"Practica10/#ejercicio-5_1","title":"Ejercicio 5","text":"<p>Crear la rama <code>bibliografia</code>.</p> <p>Cambiar a la rama <code>bibliografia</code>.</p> <p>Cambiar el fichero <code>bibliografia.txt</code> para que contenga las siguientes referencias:</p> <pre><code>Scott Chacon and Ben Straub. Pro Git. Apress.\nRyan Hodson. Ry\u2019s Git Tutorial. Smashwords (2014)\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cA\u00f1adida nueva referencia bibliogr\u00e1fica.\u201d</p> <p>Cambiar a la rama <code>master</code>.</p> <p>Cambiar el fichero <code>bibliografia.txt</code> para que contenga las siguientes referencias:</p> <pre><code>Chacon, S. and Straub, B. Pro Git. Apress.\nLoeliger, J. and McCullough, M. Version control with Git. O\u2019Reilly.\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cA\u00f1adida nueva referencia bibliogr\u00e1fica.\u201d</p> <p>Fusionar la rama <code>bibliografia</code> con la rama <code>master</code>.</p> <p>Resolver el conflicto dejando el fichero <code>bibliografia.txt</code> con las referencias:</p> <pre><code>Chacon, S. and Straub, B. Pro Git. Apress.\nLoeliger, J. and McCullough, M. Version control with Git. O\u2019Reilly.\nHodson, R. Ry\u2019s Git Tutorial. Smashwords (2014)\n</code></pre> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \u201cResuelto conflicto de bibliograf\u00eda.\u201d</p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p> </p>"},{"location":"Practica10/#ejercicios-de-repositorios-remotos","title":"Ejercicios de repositorios remotos","text":""},{"location":"Practica10/#ejercicio-1_4","title":"Ejercicio 1","text":"<p>Crear un nuevo repositorio p\u00fablico en GitHub con el nombre <code>libro-git</code>.</p> <p>A\u00f1adirlo al repositorio local del libro.</p> <p>Mostrar todos los repositorios remotos configurados.</p> <p> </p>"},{"location":"Practica10/#ejercicio-2_4","title":"Ejercicio 2","text":"<p>A\u00f1adir los cambios del repositorio local al repositorio remoto de GitHub.</p> <p>Acceder a GitHub y comprobar que se han subido los cambios mostrando el historial de versiones.</p> <p> </p>"},{"location":"Practica10/#ejercicio-3_4","title":"Ejercicio 3","text":"<p>Colaborar en el repositorio remoto <code>libro-git</code> de otro usuario.</p> <p>Clonar su repositorio <code>libro-git</code>.</p> <p>A\u00f1adir el fichero <code>autores.txt</code> que contenga el nombre del usuario y su correo electr\u00f3nico.</p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p>Hacer un commit con el mensaje \u201cA\u00f1adido autor.\u201d</p> <p>Subir los cambios al repositorio remoto.</p> <p> </p>"},{"location":"Practica11/","title":"Pr\u00e1ctica 6.1 - Dockerizaci\u00f3n del despliegue de una aplicaci\u00f3n Node.js","text":""},{"location":"Practica11/#instalacion-de-docker-engine-y-docker-compose","title":"Instalaci\u00f3n de Docker Engine y Docker Compose","text":""},{"location":"Practica11/#docker-engine","title":"Docker Engine","text":"<p>Primero, actualizamos la lista de paquetes:</p> <pre><code>sudo apt update\n</code></pre> <p></p> <p>Luego, instalamos los paquetes necesarios para que APT use repositorios a trav\u00e9s de HTTPS:</p> <pre><code>sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release\n</code></pre> <p></p> <p>A\u00f1adimos la clave GPG oficial de Docker:</p> <pre><code>curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n</code></pre> <p></p> <p>A\u00f1adimos el repositorio de Docker a APT:</p> <pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <p></p> <p>Actualizamos nuevamente la lista de paquetes:</p> <pre><code>sudo apt update\n</code></pre> <p></p> <p>Instalamos Docker Engine:</p> <pre><code>sudo apt install docker-ce docker-ce-cli containerd.io\n</code></pre> <p></p> <p>Para verificar si Docker est\u00e1 instalado correctamente, ejecutamos:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p></p>"},{"location":"Practica11/#docker-compose","title":"Docker Compose","text":"<p>Para instalar Docker Compose, descargamos una versi\u00f3n estable (en este caso, la 2.20.2):</p> <pre><code>sudo curl -SL https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-$(uname -m) -o /usr/local/bin/docker-compose\n</code></pre> <p></p> <p>Le damos permisos ejecutables:</p> <pre><code>sudo chmod +x /usr/local/bin/docker-compose\n</code></pre> <p></p> <p>Verificamos si Docker Compose est\u00e1 instalado correctamente:</p> <pre><code>docker-compose --version\n</code></pre> <p></p>"},{"location":"Practica11/#despliegue-con-docker","title":"Despliegue con Docker","text":"<p>En primer lugar, si eliminast\u00e9is el repositorio en su momento, deb\u00e9is volver a clonarlo en vuestra Debian, en caso contrario obviad este paso:</p> <pre><code>$ git clone https://github.com/raul-profesor/DAW_practica_6.1_2024.git\n</code></pre> <p></p> <p>Ahora, puesto que la aplicaci\u00f3n ya viene con el Dockerfile necesario dentro del directorio para construir la imagen y correr el contenedor, vamos a estudiar su contenido.</p>"},{"location":"Practica11/#tarea","title":"Tarea","text":"<p>Completa este Dockerfile con las opciones/directivas adecuadas, leed los comentarios y pod\u00e9is apoyaros en la teor\u00eda, en este cheatsheet, en este otro o en cualquiera que encontr\u00e9is. </p> <p>As\u00ed pues, tener nuestra aplicaci\u00f3n corriendo es cuesti\u00f3n de un par de comandos.</p> <p>Hacemos un build de la imagen de Docker. Le indicamos que \u00e9sta se llama <code>librodirecciones</code> y que haga el build con el contexto del directorio actual de trabajo, as\u00ed como del Dockerfile que hay en \u00e9l:</p> <pre><code>$ docker build -t librodirecciones .\n</code></pre> <p></p> <p>Y por \u00faltimo, iniciamos el contenedor con nuestra aplicaci\u00f3n. Ahora s\u00ed, con la opci\u00f3n <code>-p</code>, le indicamos que escuche conexiones entrantes de cualquier m\u00e1quina en el puerto 3000 de nuestra m\u00e1quina anfitri\u00f3n que haremos coincidir con el puerto 3000 del contenedor (<code>-p 3000:3000</code>). Y con la opci\u00f3n <code>-d</code> lo haremos correr en modo demonio, en background:</p> <pre><code>$ docker run -p 3000:3000 -d librodirecciones\n</code></pre> <p></p> <p>Tras esto s\u00f3lo queda comprobar que al intentar acceder desde nuestra m\u00e1quina a la aplicaci\u00f3n: <code>http://IP_Maq_Virtual:3000</code> se produce un error de conexi\u00f3n. </p> <p>Esto sirve para ilustrar un punto importante de los contenedores: poseen su propia red. La aplicaci\u00f3n, por defecto, intenta buscar la base de datos en nuestro localhost pero, t\u00e9cnicamente, est\u00e1 en otro host (su contenedor).</p> <p>A pesar de que todos los contenedores corren en la misma m\u00e1quina, cada uno es considerado un host diferente y por eso la aplicaci\u00f3n falla al conectar.</p> <p>Podr\u00edamos utilizar los comandos network de Docker para solucionar el asunto. En lugar de eso, introduciremos el concepto de Docker Compose para administrar contenedores.</p>"},{"location":"Practica11/#docker-compose_1","title":"Docker Compose","text":"<p>Docker Compose es una herramienta para gestionar aplicaciones multicontenedor. En Linux tiene que ser instalado por separado, consultad su documentaci\u00f3n para ello.</p> <p>Docker Compose puede:</p> <ul> <li>Iniciar y detener m\u00faltiples contenedores en secuencia.</li> <li>Conectar contenedores utilizando una red virtual.</li> <li>Manejar la persistencia de datos usando Docker Volumes.</li> <li>Establecer variables de entorno.</li> <li>Construir o descargar im\u00e1genes de contenedores seg\u00fan sea necesario.</li> </ul> <p>Docker Compose utiliza un archivo de definici\u00f3n YAML para describir toda la aplicaci\u00f3n. En nuestro caso:</p> <pre><code>version: \"3.9\"\nservices:\n    postgres:\n        image: postgres:latest\n        environment:\n            POSTGRES_USER: postgres\n            POSTGRES_PASSWORD: postgres\n        ports: \n            - '5432:5432'\n        volumes:\n            - addressbook-db:/var/lib/postgresql/data\n\n    addressbook:\n        build:\n            context: .\n        environment:\n            DB_SCHEMA: postgres\n            DB_USER: postgres\n            DB_PASSWORD: postgres\n            DB_HOST: postgres\n        depends_on:\n            - postgres\n        ports:\n            - '3000:3000'\n\nvolumes:\n    addressbook-db:\n</code></pre> <p>As\u00ed las cosas, para levantar nuestra infraestructura basada en contenedores no tenemos m\u00e1s que hacer:</p> <pre><code>$ docker compose run addressbook npm run migrate\n</code></pre> <p> Esto crear\u00e1 las tablas necesarias en la base de datos.</p> <p>Y construiremos nuestros contenedores a partir de las im\u00e1genes:</p> <pre><code>$ docker compose up --build -d\n</code></pre> <p> Una vez construidas las im\u00e1genes, podemos levantar los contenedores:</p> <p>Pod\u00e9is correr unos tests para comprobar que la aplicaci\u00f3n funciona correctamente con:</p> <pre><code>$ docker compose run addressbook npm test\n</code></pre> <p></p> <p></p>"},{"location":"Practica11/#tarea_1","title":"Tarea","text":"<p>Probad que la aplicaci\u00f3n junto con la BBDD funciona correctamente. El funcionamiento de la API es:</p> <ul> <li><code>GET /persons/all</code> muestra todas las personas en el libro de direcciones</li> <li><code>GET /persons/1</code> muestra la persona con el id 1</li> <li><code>PUT /persons/</code> a\u00f1ade una persona al libro de direcciones</li> <li><code>DELETE /persons/1</code> elimina a la persona con el id 1</li> </ul> <p>Ejemplos:</p> <pre><code>curl -X PUT http://IP_APLICACION:3000/persons -H 'Content-Type: application/json' -d '{\"id\": 1, \"firstName\": \"Ra\u00fal\", \"lastName\": \"Profesor\"}'\n\ncurl -X GET http://localhost:3000/persons -H 'Content-Type: application/json'\n</code></pre> <p></p>"},{"location":"Practica12/","title":"Pr\u00e1ctica 6.2 - Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y docker-compose","text":""},{"location":"Practica12/#instalacion-de-docker-compose","title":"Instalaci\u00f3n de docker-compose","text":""},{"location":"Practica12/#proceso-de-dockerizacion-de-nginxphpmysql","title":"Proceso de dockerizaci\u00f3n de Nginx+PHP+MySQL","text":""},{"location":"Practica12/#1-estructura-de-directorios","title":"1. Estructura de directorios","text":"<p>La estructura de directorios que debe quedar es esta:</p> <pre><code>/usuario/home/practica6-2/\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 nginx\n\u2502   \u251c\u2500\u2500 default.conf\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 php\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 www\n  \u2514\u2500\u2500 html\n    \u2514\u2500\u2500 index.php\n</code></pre> <p>Se pueden ir crrando los directorios y los archivos segun se este haciendo la practica o todo a la vez, con comandos como estos:</p> <pre><code>mkdir practica6-2\ncd practica6-2\ntouch docker-compose.yml\nmkdir nginx\ntouch nginx/default.conf\n...\n</code></pre>"},{"location":"Practica12/#2-creacion-de-un-contenedor-nginx","title":"2. Creaci\u00f3n de un contenedor Nginx","text":"<p>Para empezar, necesitamos crear y correr un contenedor Nginx que permita alojar nuestra aplicaci\u00f3n en PHP.</p> <p>Dentro de la carpeta <code>/usuario/home/practica6-2/</code> debemos haber creado o crear ahora el archivo <code>docker-compose.yml</code>.</p> <p>Y editamos este archivo </p> <pre><code>nano docker-compose.yml\n</code></pre> <p></p> <p>Y a\u00f1adimos las siguientes l\u00edneas:</p> <p></p> <p>Y lo guardamos.</p> <p>Despues ejecuutaremos lo siguiente: </p> <pre><code>docker-compose up -d\n</code></pre> <p>Con la opci\u00f3n <code>-d</code>  estamos indicando que el contenedor se ejecute en background o segundo plano.</p> <p>Para comprobar que el contenedor esta activo usamos lo siguiente:</p> <pre><code>docker ps\n</code></pre> <p></p> <p>Una vez hecho esto si nos vamos al navegador y ponemos la IP de nuestra maquina virtual y el puerto que hemos configurado (http://IP:PUERTO) nos saldra los siguiente:</p> <p></p>"},{"location":"Practica12/#3-creacion-de-un-contenedor-php","title":"3. Creaci\u00f3n de un contenedor PHP","text":"<p>Creamos la carpeta y el documento dentro de ella, si no se hab\u00eda hecho antes:</p> <pre><code>mkdir -p /home/usuario/practica6-2/www/html\nnano /home/usuario/practica6-2/www/html/index.php\n</code></pre> <p></p> <p>Y dentro de <code>index.php</code> a\u00f1adimos el siguiente c\u00f3digo:</p> <p></p> <p>Se guarda el archivo y crea, si no estaba creado, un directorio llamado <code>nginx</code> dentro del directorio del proyecto:</p> <pre><code>mkdir /home/usuario/practica6-2/nginx\n</code></pre> <p>Crearamos el archivo de configuraci\u00f3n por defecto para que Nginx pueda correr la aplicaci\u00f3n PHP:</p> <pre><code>nano /home/usuario/practica6-2/nginx/default.conf\n</code></pre> <p></p> <p>Y dentro de ese archivo, colocaremos la siguiente configuraci\u00f3n:</p> <p></p> <p>Codigo completo:</p> <pre><code>server {\n\n   listen 80 default_server;\n   root /var/www/html;\n   index index.html index.php;\n\n   charset utf-8;\n\n   location / {\n    try_files $uri $uri/ /index.php?$query_string;\n   }\n\n   location = /favicon.ico { access_log off; log_not_found off; }\n   location = /robots.txt { access_log off; log_not_found off; }\n\n   access_log off;\n   error_log /var/log/nginx/error.log error;\n\n   sendfile off;\n\n   client_max_body_size 100m;\n\n   location ~ .php$ {\n    fastcgi_split_path_info ^(.+.php)(/.+)$;\n    fastcgi_pass php:9000;\n    fastcgi_index index.php;\n    include fastcgi_params;\n    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n    fastcgi_intercept_errors off;\n    fastcgi_buffer_size 16k;\n    fastcgi_buffers 4 16k;\n  }\n\n   location ~ /.ht {\n    deny all;\n   }\n}\n</code></pre> <p>Guardamos el archivo y ahora creamos el <code>Dockerfile</code> dentro del directorio <code>nginx</code></p> <pre><code>nano /home/usuario/practica6-2/nginx/Dockerfile\n</code></pre> <p></p> <p>Y dentro de este archivo:</p> <p></p> <p>Y ahora editamos nuestro archivo <code>docker-compose.yml</code>:</p> <p></p> <p>As\u00ed pues, ejecutaremos el nuevo contenedor volviendo a ejecutar compose. Se debe ejecutar el comando en el mismo directorio donde tengamos nuestro archivo <code>docker-compose.yml</code>:</p> <pre><code>cd /home/usuario/practica6-2\ndocker-compose up -d\n</code></pre> <p></p> <p>Y comprobamos que los contenedores est\u00e1n corriendo:</p> <pre><code>docker ps\n</code></pre> <p>Se debe de ver algo similar a esto:</p> <pre><code>CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS          PORTS                               NAMES\n82c8baf15221   docker-project_nginx   \"/docker-entrypoint.\u2026\"   23 seconds ago   Up 22 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx-container\n10778c6686d8   php:7.0-fpm            \"docker-php-entrypoi\u2026\"   25 seconds ago   Up 23 seconds   9000/tcp                            php-container\n</code></pre> <p></p> <p>Y si ahora volvemos a acceder a la ip de la maquina virtual desde el navegador, veremos la p\u00e1gina Hola mundo.</p> <p></p>"},{"location":"Practica12/#4-creacion-de-un-contenedor-para-datos","title":"4. Creaci\u00f3n de un contenedor para datos","text":"<p>En este paso crearemos un contenedor independiente que se encargar\u00e1 de contener los datos y lo enlazaremos con el resto de contenedores.</p> <p>Para hacer esto, volvemos a editar el <code>docker-compose.yml</code>:</p> <pre><code>nano /usuario/home/practica6-2/docker-compose.yml\n</code></pre> <p>Y a\u00f1adiremos un nuevo servicio a los que ya ten\u00edamos, quedando as\u00ed:</p> <p></p> <p>As\u00ed que para recrear y lanzar todos los contenedores ejecutamos de nuevo dentro del directorio donde se encuentra el archivo:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Y volvemos a verificar que est\u00e1n corriendo todos:</p> <pre><code>docker ps -a\n</code></pre> <p>Debiendo ver algo como:</p> <pre><code>CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS                      PORTS                               NAMES\n849315c7ffc0   docker-project_nginx   \"/docker-entrypoint.\u2026\"   27 seconds ago   Up 25 seconds               0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx-container\n59a0d7040fd8   php:7.0-fpm            \"docker-php-entrypoi\u2026\"   28 seconds ago   Up 27 seconds               9000/tcp                            php-container\nfbca95944234   php:7.0-fpm            \"docker-php-entrypoi\u2026\"   29 seconds ago   Exited (0) 28 seconds ago                                       app-data-container\n</code></pre> <p></p>"},{"location":"Practica12/#5-creacion-de-un-contenedor-mysql","title":"5. Creaci\u00f3n de un contenedor MySQL","text":"<p>En esta secci\u00f3n crearemos un contenedor de una base de datos MySQL y lo enlazaremos con el resto de contenedores.</p> <p>Primero, modificaremos la imagen PHP e instalaremos la extensi\u00f3n PHP para MySQL</p> <p>Creamos, si no lo ten\u00edamos ya, nuestro directorio <code>php</code> y dentro de \u00e9l, el archivo <code>Dockerfile</code>:</p> <pre><code>mkdir /home/usuario/practica6-2/php\nnano /home/usuario/practica6-2/php/Dockerfile\n</code></pre> <p></p> <p>Y dentro del <code>Dockerfile</code> ponemos:</p> <p></p> <p>Y una vez m\u00e1s, debemos editar <code>docker-compose.yml</code> con el objetivo de que se creen el contenedor para MySQL y el contenedor de los datos de MySQL que contendr\u00e1 la base de datos y las tablas:</p> <p></p> <p>Despu\u00e9s de guardar este archivo, editamos el archivo <code>index.php</code> y hacemos algunos cambios para comprobar la conexi\u00f3n a la base de datos.</p> <p>El archivo <code>index.php</code> debe quedar as\u00ed:</p> <p></p> <p>Se Guarda el archivo y se lanzan los contenedores una vez m\u00e1s:</p> <pre><code>docker-compose up -d\n</code></pre> <p></p> <p>Y verificamos que est\u00e1n ejecut\u00e1ndose:</p> <pre><code>docker ps -a\n</code></pre> <p>Y veremos:</p> <pre><code>CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS                      PORTS                               NAMES\nd3e82747fe0d   mysql:5.7              \"docker-entrypoint.s\u2026\"   39 seconds ago   Up 38 seconds               3306/tcp, 33060/tcp                 mysql-container\n606320e5a7f8   mysql:5.7              \"docker-entrypoint.s\u2026\"   41 seconds ago   Exited (0) 39 seconds ago                                       mysql-data-container\nca4f63797d11   docker-project_php     \"docker-php-entrypoi\u2026\"   2 hours ago      Up 2 hours                  9000/tcp                            php-container\n849315c7ffc0   docker-project_nginx   \"/docker-entrypoint.\u2026\"   2 hours ago      Up 2 hours                  0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx-container\nfbca95944234   php:7.0-fpm            \"docker-php-entrypoi\u2026\"   2 hours ago      Exited (0) 39 seconds ago                                       app-data-container\n</code></pre> <p></p>"},{"location":"Practica12/#6-verificacion-de-conexion-a-la-base-de-datos","title":"6. Verificaci\u00f3n de conexi\u00f3n a la base de datos","text":"<p>Si ahora accedemos a la ip de la maquina virtual desde el navegador como hemos hecho antes, deber\u00edamos obtener la siguiente pantalla:</p> <p></p> <p>nos dice que no tenemos ninguna tabla en la base de datos <code>mydb</code>.</p> <p>Eso es debido a que tenemos que cambiar la variable $root y la variable $password del index.php</p> <p>Es decir:</p> <pre><code>nano /home/usuario/www/html/index.php\n</code></pre> <p>Y cambiar las l\u00edneas:</p> <pre><code>$user = \"root\";\n$password = \"secret\";\n</code></pre> <p></p> <p>Una vez hecho esto nos dara este resultado:</p> <p></p>"},{"location":"Practica13/","title":"Despliegue con Docker de NGINX + demonio de autenticaci\u00f3n LDAP + OpenLDAP","text":"<p>Para esta pr\u00e1ctica nos crearemos un directorio que contendr\u00e1 nuestro <code>index.html</code> con el siguiente texto:</p> <pre><code>$ mkdir app\n\n$ cat &lt;&lt; EOF &gt; app/index.html\n&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;\u00a1Hola Mundo!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nEOF\n</code></pre> <p>As\u00ed como otro directorio, con el contenido de la configuraci\u00f3n pertinente de Nginx:</p> <pre><code>$ mkdir conf\n\n$ cat &lt;&lt; EOF &gt; conf/ldap_nginx.conf\n  server {\n    listen 8080;\n\n    location = / {\n     auth_request /auth-proxy;\n    }\n\n    location = /auth-proxy {\n     internal;\n\n     proxy_pass http://nginx-ldap:8888;\n\n     # URL y puerto para conectarse al servidor LDAP\n     proxy_set_header X-Ldap-URL \"ldap://openldap:1389\";\n\n     # Base DN\n     proxy_set_header X-Ldap-BaseDN \"dc=example,dc=org\";\n\n     # Bind DN\n     proxy_set_header X-Ldap-BindDN \"cn=admin,dc=example,dc=org\";\n\n     # Bind password\n     proxy_set_header X-Ldap-BindPass \"adminpassword\";\n    }\n   }\nEOF\n</code></pre> <p></p> <p>Y ahora, procedemos con el siguiente <code>docker-compose.yml</code>:</p> <pre><code>version: '2'\n\nservices:\n  nginx-ldap:\n  image: bitnami/nginx-ldap-auth-daemon-archived\n  ports:\n    - 8888:8888\n  nginx:\n  image: bitnami/nginx\n  ports: \n   - 8080:8080\n  volumes:\n   - ./app:/app\n   - ./conf/ldap_nginx.conf:/opt/bitnami/nginx/conf/server_blocks/ldap_nginx.conf\n  openldap:\n  image: bitnami/openldap\n  ports:\n    - '1389:1389'    \n  environment:\n    - LDAP_ADMIN_USERNAME=admin\n    - LDAP_ADMIN_PASSWORD=adminpassword\n    - LDAP_USERS=customuser\n    - LDAP_PASSWORDS=custompassword\n</code></pre> <p></p> <p>Tras esto s\u00f3lo queda ejecutar compose:</p> <pre><code>docker-compose up\n</code></pre> <p></p>"},{"location":"Practica13/#tarea","title":"Tarea","text":"<p>Comprobar que puedes acceder a <code>http://IP_Maq_Virtual:8080</code> y loguearte en el servidor LDAP que acabas de desplegar.</p> <p></p>"},{"location":"Practica13/#despliegue-con-docker-de-php-apache-con-autenticacion-ldap","title":"Despliegue con Docker de PHP + Apache con autenticaci\u00f3n LDAP","text":"<p>Creamos un directorio que se llame <code>Practica6.3</code>.</p> <p>En primer lugar, como es obvio, dentro del directorio creado debemos crear el <code>index.php</code> de nuestra aplicaci\u00f3n:</p> <pre><code>&lt;?php\necho 'Ey, hola usuario autenticado por LDAP!';\n</code></pre> <p></p> <p>Dentro de nuestro directorio de trabajo, creado anteriormente, crearemos otro directorio llamado <code>Docker</code> y dentro de \u00e9l, un <code>Dockerfile</code> (<code>./Docker/Dockerfile</code>).</p> <p></p> <p></p> <p>Ahora crearemos el archivo <code>./Docker/ldap-demo.conf</code>, que es la configuraci\u00f3n LDAP. Aqu\u00ed establecemos los criterios de conexi\u00f3n con el contenedor de OpenLDAP, password y URL.</p> <pre><code># ./Docker/ldap-demo.conf\nPassEnv LDAP_BIND_ON\nPassEnv LDAP_PASSWORD\nPassEnv LDAP_URL\n&lt;AuthnProviderAlias ldap demo&gt;\n  AuthLDAPBindDN ${LDAP_BIND_ON}\n  AuthLDAPBindPassword ${LDAP_PASSWORD}\n  AuthLDAPURL ${LDAP_URL}\n&lt;/AuthnProviderAlias&gt;\n</code></pre> <p></p> <p>Creamos el archivo <code>.htaccess</code>:</p> <pre><code># .Docker/.htaccess\nAuthBasicProvider demo\nAuthType Basic\nAuthName \"Protected Area\"\nRequire valid-user\n</code></pre> <p></p> <p>Dentro de nuestro directorio de trabajo, construimos la imagen con el siguiente comando:</p> <pre><code>docker build . \\\n  -t docker-ldap \\\n  -f ./Docker/dockerfile\n</code></pre> <p></p> <p>Corremos el contenedor indicando las credenciales de nuestra cuenta LDAP mediante variables de entorno con la flag <code>-e</code>. Para este caso, vamos a probar un servidor LDAP externo.</p> <p>Utilizaremos un servidor p\u00fablico en Internet dedicado a pruebas: https://www.freeipa.org/page/Demo. </p> <pre><code>docker run -d \\\n  -p 3000:80 \\\n  --name ldap_demo \\\n  -e LDAP_BIND_ON='uid=admin,cn=users,cn=accounts,dc=demo1,dc=freeipa,dc=org' \\\n  -e LDAP_PASSWORD='Secret123' \\\n  -e LDAP_URL='LDAP://ipa.demo1.freeipa.org' \\\n  docker-ldap\n</code></pre> <p></p> <p></p>"},{"location":"Practica2/","title":"PRACTICA 2.2","text":""},{"location":"Practica2/#paquetes-necesarios","title":"Paquetes necesarios","text":"<p>Para esta pr\u00e1ctica podemos utilizar la herramienta openssl para crear las contrase\u00f1as.</p> <p>En primer lugar debemos comprobar si el paquete est\u00e1 instalado:</p> <pre><code>dpkg -l | grep openssl\n\n</code></pre> <p>Y si no lo estuviera, instalarlo con el siguiente comando:</p> <pre><code>sudo apt update sudo apt install openssl\n</code></pre> <p></p>"},{"location":"Practica2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Crearemos un archivo oculto llamado \u201c.htpasswd\u201d en el directorio de configuraci\u00f3n <code>/etc/nginx</code> donde guardar nuestros usuarios y contrase\u00f1as (la <code>-c</code> es para crear el archivo):</p> <pre><code>sudo sh -c \"echo -n 'vuestro_nombre:' &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Ahora crearemos un password cifrado para el usuario:</p> <pre><code>sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Este proceso se podr\u00e1 repetir para tantos usuarios como haga falta.</p> <p>Crea dos usuarios, uno con tu nombre y otro con tu primer apellido. Comprueba que el usuario y la contrase\u00f1a aparecen cifrados en el fichero:</p> <p><code>cat /etc/nginx/.htpasswd</code></p> <p></p>"},{"location":"Practica2/#configurando-el-servidor-nginx-para-usar-autenticacion-basica","title":"Configurando el servidor Nginx para usar autenticaci\u00f3n b\u00e1sica","text":"<p>Editaremos la configuraci\u00f3n del server block sobre el cual queremos aplicar la restricci\u00f3n de acceso. Utilizaremos para esta autenticaci\u00f3n el sitio web de la pr\u00e1ctica anterior:</p> <p></p> <p><code>sudo nano /etc/nginx/sites-available/nombre_web</code></p> <p></p> <p></p> <p>Debemos decidir qu\u00e9 recursos estar\u00e1n protegidos. Nginx permite a\u00f1adir restricciones a nivel de servidor o en un <code>location</code> (directorio o archivo) espec\u00edfico. Para nuestro ejemplo, vamos a proteger el document root (la ra\u00edz, la p\u00e1gina principal) de nuestro sitio.</p> <p>Utilizaremos la directiva <code>auth_basic</code> dentro del <code>location</code> y le pondremos el nombre a nuestro dominio que ser\u00e1 mostrado al usuario al solicitar las credenciales. Por \u00faltimo, configuramos Nginx para que utilice el fichero que previamente hemos creado con la directiva <code>auth_basic_user_file</code>:</p> <p></p> <p>Una vez terminada la configuraci\u00f3n, reiniciamos el servicio para que aplique nuestra pol\u00edtica de acceso:</p> <p><code>sudo systemctl restart nginx</code></p> <p></p>"},{"location":"Practica2/#probando-la-nueva-configuracion","title":"PROBANDO LA NUEVA CONFIGURACION","text":""},{"location":"Practica2/#comprobacion-1","title":"Comprobaci\u00f3n 1","text":"<p>Comprueba desde tu m\u00e1quina f\u00edsica/anfitri\u00f3n que puedes acceder a <code>http://nombre-sitio-web</code> y que se te solicita autenticaci\u00f3n.</p> <p></p>"},{"location":"Practica2/#comprobacion-2","title":"Comprobaci\u00f3n 2","text":"<p>Comprueba que si decides cancelar la autenticaci\u00f3n, se te negar\u00e1 el acceso al sitio con un error. \u00bfQu\u00e9 error es?</p> <p></p>"},{"location":"Practica2/#registro-del-log-de-error","title":"Registro del log de error","text":"<p>Cuando hemos configurado el siguiente bloque:</p> <pre><code>location / { auth_basic \"\u00c1rea restringida\"; auth_basic_user_file /etc/nginx/.htpasswd; try_files $uri $uri/ =404; }\n</code></pre> <p>La autenticaci\u00f3n se aplica al directorio/archivo que le indicamos en la declaraci\u00f3n del <code>location</code> y que en este caso es la ra\u00edz <code>/</code>.</p> <p>As\u00ed pues, esta restricci\u00f3n se aplica al directorio ra\u00edz o base donde residen los archivos del sitio web, que es:</p> <p><code>/var/www/webraul/html/simple-static-website</code></p> <p>Y a todos los archivos que hay dentro, ya que no hemos especificado ninguno en concreto.</p>"},{"location":"Practica2/#combinacion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP","text":"<p>La autenticaci\u00f3n b\u00e1sica HTTP puede ser combinada de forma efectiva con la restricci\u00f3n de acceso por direcci\u00f3n IP. Se pueden implementar dos escenarios:</p> <ul> <li>Un usuario debe cumplir ambas cosas: estar autenticado y tener una IP v\u00e1lida.</li> <li>Un usuario debe, o bien estar autenticado, o bien tener una IP v\u00e1lida.</li> </ul> <p>Veamos c\u00f3mo lo har\u00edamos:</p>"},{"location":"Practica2/#como-permitir-o-denegar-acceso-sobre-una-ip-concreta-directivas-allow-y-deny-respectivamente","title":"C\u00f3mo permitir o denegar acceso sobre una IP concreta (directivas <code>allow</code> y <code>deny</code>, respectivamente).","text":"<p>Dentro del server block o archivo de configuraci\u00f3n del dominio web, que recordad est\u00e1 en el directorio <code>sites-available</code>:</p> <p>El acceso se garantizar\u00e1 a la IP <code>192.168.1.1/24</code>, excluyendo a la direcci\u00f3n <code>192.168.1.2</code>.</p> <p>Hay que tener en cuenta que las directivas <code>allow</code> y <code>deny</code> se ir\u00e1n aplicando en el orden en el que aparecen en el archivo.</p> <p>Aqu\u00ed aplican sobre la <code>location /api</code> (esto es s\u00f3lo un ejemplo de un hipot\u00e9tico directorio o archivo), pero podr\u00edan aplicar sobre cualquiera, incluida todo el sitio web, la <code>location</code> ra\u00edz <code>/</code>.</p> <p>La \u00faltima directiva <code>deny all</code> quiere decir que, por defecto, denegaremos el acceso a todo el mundo. Por eso hay que poner los <code>allow</code> y <code>deny</code> m\u00e1s espec\u00edficos justo antes de esta, porque al evaluarse en orden de aparici\u00f3n, si los pusi\u00e9ramos debajo se denegar\u00eda el acceso a todo el mundo, puesto que <code>deny all</code> ser\u00eda lo primero que se evaluar\u00eda.</p>"},{"location":"Practica2/#combinar-la-restriccion-ip-y-la-autenticacion-http-con-la-directiva-satisfy","title":"Combinar la restricci\u00f3n IP y la autenticaci\u00f3n HTTP con la directiva <code>satisfy</code>.","text":"<p>Si establecemos el valor de la directiva a <code>all</code>, el acceso se permite si el cliente satisface ambas condiciones (IP y usuario v\u00e1lido). Si lo establecemos a <code>any</code>, el acceso se permite si se satisface al menos una de las dos condiciones.</p>"},{"location":"Practica2/#tareas","title":"Tareas","text":""},{"location":"Practica2/#tarea-1","title":"Tarea 1","text":"<p>Configura Nginx para que no deje acceder con la IP de la m\u00e1quina anfitriona al directorio ra\u00edz de una de tus dos webs. Modifica su server block o archivo de configuraci\u00f3n. Comprueba c\u00f3mo se deniega el acceso:</p> <p>Para hacer esto nos deberemos ir al archivo <code>etc/nginx/sites-available/servidor1</code> y a\u00f1adir la siguiente l\u00ednea en <code>location /</code>:</p> <p></p> <p>Una vez terminado reiniciamos el servidor nginx con el comando:</p> <p><code>sudo systemctl restart nginx</code></p> <p>Muestra la p\u00e1gina de error en el navegador.</p> <p></p> <p>Muestra el mensaje de error de <code>error.log</code>.</p> <p></p>"},{"location":"Practica2/#tarea-2","title":"Tarea 2","text":"<p>Configura Nginx para que desde tu m\u00e1quina anfitriona se tenga que tener tanto una IP v\u00e1lida como un usuario v\u00e1lido, ambas cosas a la vez, y comprueba que s\u00ed puedes acceder sin problemas.</p> <p>Para hacer esto se debe de tener un usuario web con su contrase\u00f1a ya definido. Como ya lo tenemos, solo tenemos que poner esto en el archivo <code>etc/nginx/sites-available/servidor1</code>:</p> <p></p> <p>y reiniciar el servidor con:</p> <p><code>sudo systemctl restart nginx</code></p> <p></p> <p>L</p> <p>Y este es el registro de <code>access.log</code>:</p> <p></p>"},{"location":"Practica2/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"Practica2/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Supongamos que yo soy el cliente con la IP <code>172.1.10.15</code> e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, equivoc\u00e1ndome al poner el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?</p> <pre><code>location /web_muy_guay { satisfy all;\ndeny 172.1.10.6; allow 172.1.10.15; allow 172.1.3.14; deny all; auth_basic \"Cuesti\u00f3n final 1\"; auth_basic_user_file conf/htpasswd; }\n</code></pre>"},{"location":"Practica2/#solucion","title":"Soluci\u00f3n","text":"<p>Debido a que la directiva <code>satisfy all</code> exige que ambas condiciones (IP v\u00e1lida y autenticaci\u00f3n b\u00e1sica correcta) se cumplan para permitir el acceso, no podr\u00e1s acceder al directorio si te equivocas en la autenticaci\u00f3n b\u00e1sica, incluso si tu IP es permitida.</p>"},{"location":"Practica2/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Supongamos que yo soy el cliente con la IP <code>172.1.10.15</code> e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?</p> <pre><code>location /web_muy_guay { satisfy all;\ndeny all; deny 172.1.10.6; allow 172.1.10.15; allow 172.1.3.14; auth_basic \"Cuesti\u00f3n final 2: The revenge\"; auth_basic_user_file conf/htpasswd; }\n</code></pre>"},{"location":"Practica2/#solucion_1","title":"Soluci\u00f3n","text":"<p>Debido a que la directiva <code>satisfy all</code> exige que ambas condiciones (IP v\u00e1lida y autenticaci\u00f3n b\u00e1sica correcta) se cumplan para permitir el acceso, ya que has ingresado bien el usuario y la contrase\u00f1a y la IP est\u00e1 permitida, se podr\u00e1 acceder sin problemas.</p>"},{"location":"Practica2/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Supongamos que yo soy el cliente con lP 172.1.10.15 e intento acceder al directorio <code>web_muy_guay</code> de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;    \n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre>"},{"location":"Practica2/#solucion_2","title":"Solucion","text":"<p>No podr\u00e1s acceder al directorio web_muy_guay porque, aunque la autenticaci\u00f3n es correcta, la IP 172.1.10.15 est\u00e1 expl\u00edcitamente denegada.</p>"},{"location":"Practica2/#cuestion-4","title":"Cuesti\u00f3n 4","text":"<p>A lo mejor no sab\u00e9is que tengo una web para documentar todas mis excursiones espaciales con Jeff, es esta: Jeff Bezos y yo</p> <p>Supongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n b\u00e1sica a la URL:Proyectos</p> <p>Completa la configuraci\u00f3n para conseguirlo:</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre>"},{"location":"Practica2/#solucion_3","title":"Solucion","text":"<p>La configuracion actualizada ser\u00eda :</p> <pre><code>server {\n    listen 80;\n    listen [::]:80;\n\n    root /var/www/freewebsitetemplates.com/preview/space-science;\n    index index.html index.htm index.nginx-debian.html;\n\n    server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n\n\n    location /Proyectos {\n        auth_basic \"Acceso restringido a Proyectos\";  \n        auth_basic_user_file /etc/nginx/.htpasswd;  \n\n        try_files $uri $uri/ =404;  \n    }\n}\n</code></pre>"},{"location":"Practica3/","title":"PRACTICA 3.3","text":"<p>Vamos a configurar dos Debian con sendos servidores Nginx. Ten\u00e9is la m\u00e1quina virtual inicial y deb\u00e9is clonarla para tener una segunda:</p> <p>Uno servir\u00e1 las p\u00e1ginas web que ya hemos configurado, as\u00ed pues utilizaremos el servidor que ya tenemos configurado de la Pr\u00e1ctica 2.1.</p> <p>El nuevo servidor clon Debian con Nginx configurado como proxy inverso.</p> <p>Realizaremos las peticiones HTTP desde el navegador web de nuestra m\u00e1quina f\u00edsica/anfitri\u00f3n hacia el proxy clonado, que nos redirigir\u00e1 al servidor web original.</p> <p>Cuidado.</p> <p>En primer lugar, deb\u00e9is cambiar el nombre que tuviera vuestra web por el de webserver, ello implica:</p> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles para Nginx.</p> <p></p> <p>Cambiar el nombre del sitio web dentro de este archivo de configuraci\u00f3n donde haga falta.</p> <p></p> <p>No os olvid\u00e9is de eliminar el link simb\u00f3lico antiguo con el comando <code>unlink nombre_del_link</code> dentro de la carpeta <code>sites-enabled</code> y crear el nuevo para el nuevo nombre de archivo.</p> <p></p> <p></p> <p>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que el servidor escuche en el puerto 80, cambiadlo al 8080.</p> <p></p> <p>Reiniciar Nginx.</p> <p></p> <p>Ahora, cuando intentamos acceder a <code>http://ejemplo-proxy</code> (o el nombre que tuvier\u00e1is de vuestra web de las pr\u00e1cticas anteriores), en realidad estaremos accediendo al proxy, que nos redirigir\u00e1 a <code>http://webserver:8080</code>, el servidor web que acabamos de configurar para que escuche con ese nombre en el puerto 8080.</p> <p>Para ello:</p> <p>Crear un archivo de configuraci\u00f3n en <code>sites-available</code> con el nombre <code>ejemplo-proxy</code> (o el que tuvier\u00e1is vosotros).</p> <p>Este archivo de configuraci\u00f3n ser\u00e1 m\u00e1s simple, tendr\u00e1 la siguiente forma:</p> <pre><code>server { \n    listen __; \n    server_name ____________; \n    location / { \n        proxy_pass http://_________:____; \n    } \n}\n</code></pre> <p>Donde, mirando el diagrama de red y teniendo en cuenta la configuraci\u00f3n hecha hasta ahora, deb\u00e9is completar:</p> <ul> <li>El puerto donde est\u00e1 escuchando el proxy inverso.</li> <li>El nombre de vuestro dominio o sitio web original al que accedemos en el proxy.</li> <li>La directiva <code>proxy_pass</code> indica a d\u00f3nde se van a redirigir las peticiones, esto es, al servidor web. Por tanto, deb\u00e9is poner la IP y n\u00famero de puerto adecuados de vuestro sitio web configurado en el apartado anterior.</li> </ul> <p></p> <p>Crear el link simb\u00f3lico pertinente.</p> <p></p> <p>Esto es para simular la situaci\u00f3n en la que nosotros, como clientes, cuando accedamos a nuestro sitio web, no necesitemos saber c\u00f3mo est\u00e1 todo configurado, s\u00f3lo necesitamos saber el nombre de la web.</p> <p>Deb\u00e9is modificar el archivo <code>host</code> que configurast\u00e9is en la pr\u00e1ctica 2.1. Si mir\u00e1is el diagrama de red, ahora el nombre de vuestro sitio web se corresponder\u00e1 con la IP de la nueva m\u00e1quina clon que hace de proxy. Ser\u00e1 \u00e9sta la encargada de redirigirnos autom\u00e1ticamente al verdadero sitio web.</p> <p></p>"},{"location":"Practica3/#comprobaciones","title":"Comprobaciones","text":"<p>Si acced\u00e9is a vuestro sitio web, deb\u00e9is poder seguir accediendo sin problemas.</p> <p>Comprobad en los <code>access.log</code> de los dos servidores que llega la petici\u00f3n.</p> <p></p> <p>Comprobad adem\u00e1s la petici\u00f3n y respuesta con las herramientas de desarrollador de Firefox en Xubuntu. Pulsando <code>F12</code> en el navegador os aparecer\u00e1n estas herramientas.</p> <p></p>"},{"location":"Practica4/","title":"PRACTICA 2.4","text":""},{"location":"Practica4/#atencion","title":"Atenci\u00f3n","text":"<p>Ya no vamos a utilizar los sitios web que hemos configurado en las pr\u00e1cticas anteriores. Por ello, para evitarnos una serie de problemas que pueden surgir, vamos a desactivarlos.</p> <p>Dentro de la carpeta <code>/etc/nginx/sites-enabled</code> debemos ejecutar <code>unlink nombre_archivo</code> para cada uno de los archivos de los sitios web que tenemos.</p> <p></p> <p>Si no hac\u00e9is esto obtendr\u00e9is errores en todas las pr\u00e1cticas que quedan de este tema.</p>"},{"location":"Practica4/#nginx-servidor-web-1","title":"Nginx Servidor Web 1","text":"<p>El primer servidor web ser\u00e1 el servidor principal que hemos venido utilizando hasta ahora durante el curso, el original, donde tenemos instalado ya el servicio Web.</p> <p>Debemos configurar este servidor web para que sirva el siguiente <code>index.html</code> que deb\u00e9is crear dentro de la carpeta <code>/var/www/webserver1/html</code>:</p> <p></p> <p>El nombre del sitio web que deb\u00e9is utilizar en los archivos correspondientes (<code>sites-available\u2026</code>) que deb\u00e9is crear para Nginx es <code>webserver1</code>, as\u00ed como en sus configuraciones. Fij\u00e1os en las configuraciones que hicisteis en pr\u00e1cticas anteriores a modo de referencia.</p> <p>El sitio web debe escuchar en el puerto <code>8080</code>.</p> <p>Deb\u00e9is a\u00f1adir una cabecera que se llame <code>Serv_Web1_vuestronombre</code>.</p> <p></p>"},{"location":"Practica4/#nginx-servidor-web-2","title":"Nginx Servidor Web 2","text":"<p>Debe ser una m\u00e1quina Debian, clon del servidor web 1.</p> <p>En este servidor web debemos realizar una configuraci\u00f3n id\u00e9ntica al servidor web 1 pero cambiando <code>webserver1</code> por <code>webserver2</code> (tambi\u00e9n en el <code>index.html</code>), as\u00ed como el nombre de la cabecera a\u00f1adida, que ser\u00e1 <code>Serv_Web2_vuestronombre</code>.</p> <p></p>"},{"location":"Practica4/#warning","title":"Warning","text":"<p>Es importante que no quede ninguna referencia a <code>webserver1</code> por ning\u00fan archivo, de otra forma os dar\u00e1 resultados err\u00f3neos y os dificultar\u00e1 mucho encontrar el error.</p>"},{"location":"Practica4/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>Ya disponemos de los dos servidores web entre los que se van a repartir las peticiones que realice el cliente desde el navegador.</p> <p>Vamos, por tanto, a configurar el proxy inverso para que realice este reparto de peticiones:</p> <p>En <code>sites-available</code> deb\u00e9is crear el archivo de configuraci\u00f3n con el nombre <code>balanceo</code>.</p> <p>Este archivo tendr\u00e1 el siguiente formato:</p> <pre><code>upstream backend_hosts {\n    random;\n    server ________:____;\n    server ________:____;\n}\nserver {\n    listen 80;\n    server_name ________;\n    location / {\n        proxy_pass http://backend_hosts;\n    }\n}\n</code></pre> <p>Donde: El bloque upstream \u2192 son los servidores entre los que se va a repartir la carga, que son los dos que hemos configurado anteriormente.</p> <p>Si mir\u00e1is el diagrama y ten\u00e9is en cuenta la configuraci\u00f3n que hab\u00e9is hecho hasta ahora, aqu\u00ed deber\u00e9is colocar la IP de cada servidor, as\u00ed como el puerto donde est\u00e1 escuchando las peticiones web.</p> <p>A este grupo de servidores le ponemos un nombre, que es <code>backend_hosts</code>.</p> <p></p> <p></p>"},{"location":"Practica4/#aclaracion","title":"Aclaraci\u00f3n","text":"<p>En un sitio web, el backend se encarga de todos los procesos necesarios para que la web funcione de forma correcta. Estos procesos o funciones no son visibles pero tienen mucha importancia en el buen funcionamiento de un sitio web.</p> <p>El par\u00e1metro <code>random</code> lo que hace es repartir las peticiones HTTP que llegan al proxy inverso de forma completamente aleatoria entre el grupo de servidores que se haya definido en el bloque <code>upstream</code> (en nuestro caso s\u00f3lo hay dos).</p> <p>Pondremos <code>random</code> porque es lo m\u00e1s f\u00e1cil para comprobar que todo funciona bien en la pr\u00e1ctica, pero hay diferentes formas de repartir la carga (las peticiones HTTP).</p>"},{"location":"Practica4/#comprobaciones","title":"Comprobaciones","text":"<p>Si acced\u00e9is a vuestro sitio web, deb\u00e9is poder seguir accediendo sin problemas.</p> <p>Comprobad d\u00e1ndole repetidamente a F5, que acced\u00e9is cada vez a uno de los servidores. Se os mostrar\u00e1 el contenido del <code>index.html</code> del servidor correspondiente cada vez.</p> <p>Para una doble comprobaci\u00f3n, utilizando las herramientas de desarrollador, mostrad que la web que se os muestra coincide con la cabecera que ha a\u00f1adido el servidor web en la respuesta HTTP.</p> <p></p> <p></p>"},{"location":"Practica4/#comprobacion-del-balanceo-de-carga-cuando-cae-un-servidor","title":"Comprobaci\u00f3n del balanceo de carga cuando cae un servidor","text":"<p>Nuestro balanceador de carga est\u00e1 constantemente monitorizando \u201cla salud\u201d de los servidores web. De esta forma, si uno deja de funcionar por cualquier raz\u00f3n, siempre enviar\u00e1 las solicitudes a los que queden \u201cvivos\u201d. Vamos a comprobarlo:</p> <p>Para el servicio Nginx en el servidor web 1 y comprueba, de la misma forma que en el apartado anterior, que todas las solicitudes se env\u00edan ahora al servidor web 2.</p> <p>Tras iniciar de nuevo Nginx en el servidor web 1, repite el proceso con el servidor web 2.</p>"},{"location":"Practica5/","title":"Practica 2.5","text":""},{"location":"Practica5/#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado","text":"<p>Nosotros no utilizaremos certificados de ninguna CA de confianza, b\u00e1sicamente porque:</p> <ul> <li>Nuestros servicios no est\u00e1n publicados en Internet</li> <li>Estos certificados son de pago</li> </ul> <p>As\u00ed pues, nosotros crearemos nuestros propios certificados y los firmaremos nosotros mismos como si fu\u00e9ramos una CA aut\u00e9ntica para poder simular este escenario.</p> <p>Veamos pues el proceso para generar los certificados y las claves asociadas a ellos (privada/p\u00fablica). En primer lugar debemos crear el siguiente directorio:</p> <pre><code>/etc/nginx/ssl\n</code></pre> <p></p> <p>Podemos crear el certificado y las claves de forma simult\u00e1nea con un \u00fanico comando, donde:</p> <ul> <li><code>openssl</code>: esta es la herramienta por l\u00ednea de comandos b\u00e1sica para crear y administrar certificados, claves y otros archivos OpenSSL.</li> <li> <p><code>req</code>: este subcomando se utiliza para generar una solicitud de certificados y tambi\u00e9n solicitudes de firma de certificados (CSR).</p> </li> <li> <p><code>-x509</code>: Esto modifica a\u00fan m\u00e1s el subcomando anterior al decirle a la herramienta que queremos crear un certificado autofirmado en lugar de generar una solicitud de firma de certificado, como suceder\u00eda normalmente.</p> </li> <li><code>-nodes</code>: Esto le dice a OpenSSL que omita la opci\u00f3n de asegurar nuestro certificado con contrase\u00f1a. Necesitamos que Nginx pueda leer el archivo sin la intervenci\u00f3n del usuario cuando se inicia el servidor. Una contrase\u00f1a evitar\u00eda que esto sucediera ya que tendr\u00edamos que introducirla a mano despu\u00e9s de cada reinicio.</li> <li><code>-days 365</code>: esta opci\u00f3n establece el tiempo durante el cual el certificado se considerar\u00e1 v\u00e1lido. Lo configuramos para un a\u00f1o.</li> <li><code>-newkey rsa:2048</code>: Esto especifica que queremos generar un nuevo certificado y una nueva clave al mismo tiempo. No creamos la clave necesaria para firmar el certificado en un paso anterior, por lo que debemos crearla junto con el certificado. La <code>rsa:2048</code> parte le dice que cree una clave RSA de 2048 bits de longitud.</li> <li><code>-keyout</code>: este par\u00e1metro le dice a OpenSSL d\u00f3nde colocar el archivo de clave privada generado que estamos creando.</li> <li><code>-out</code>: Esto le dice a OpenSSL d\u00f3nde colocar el certificado que estamos creando.</li> </ul> <p>El comando completo ser\u00eda as\u00ed:</p> <pre><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt\n</code></pre> <p></p> <p>Os solicitar\u00e1 que introduzc\u00e1is una serie de par\u00e1metros, como v\u00e9is en el recuadro rojo de abajo de la imagen. Deb\u00e9is introducir los mismos par\u00e1metros que en la imagen excepto en el \u201cOrganizational Unit Name\u201d que v\u00e9is recuadrado en amarillo. Ah\u00ed deber\u00e9is poner <code>2DAW \u2013 DEAW - Vuestronombre</code>.</p>"},{"location":"Practica5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el proxy inverso","text":"<p>De la pr\u00e1ctica anterior, dentro del directorio <code>/etc/nginx/sites-available</code> ya deb\u00e9is tener el archivo de configuraci\u00f3n llamado <code>balanceo</code>. Es precisamente aqu\u00ed donde realizaremos la configuraci\u00f3n para que el acceso al sitio web se realice mediante SSL (HTTPS).</p> <p>Dentro del bloque <code>server {\u2026}</code> deb\u00e9is cambiar el puerto de escucha (<code>listen 80</code>) por lo que v\u00e9is en la imagen de abajo, a\u00f1adiendo las siguientes l\u00edneas de configuraci\u00f3n tambi\u00e9n, de tal forma que quede:</p> <pre><code>server {\n    listen 443 ssl;\n    ssl_certificate /etc/nginx/ssl/nginx.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    server_name balanceo;\n    access_log /var/log/nginx/https_access.log;\n}\n</code></pre> <p>Donde le est\u00e1is diciendo que:</p> <ul> <li>Escuche en el puerto 443 \u2192 Puerto por defecto de HTTPS</li> <li>El directorio donde est\u00e1 el certificado que hab\u00e9is generado anteriormente</li> <li>El directorio donde est\u00e1 la clave que hab\u00e9is generado anteriormente</li> <li>Los protocolos y tipos de cifrados que se pueden utilizar \u2192 Estas son las versiones de protocolos y los tipos de cifrados considerados seguros a d\u00eda de hoy (hay muchos m\u00e1s pero no se consideran seguros actualmente)</li> <li><code>server_name</code> ya lo ten\u00edais de la pr\u00e1ctica anterior, no hace falta tocarlo</li> <li>El archivo donde se guardan los logs cambia de nombre, ahora ser\u00e1 <code>https_access.log</code></li> </ul> <p></p> <p>Recordad que tras modificar cualquier configuraci\u00f3n de un servicio, hay que reiniciar el servicio, en este caso Nginx.</p> <p></p>"},{"location":"Practica5/#comprobaciones","title":"Comprobaciones","text":"<p>Si acced\u00e9is ahora a <code>https://balanceo</code> os deber\u00eda saltar un aviso de seguridad debido a que nuestro certificado es autofirmado, como coment\u00e1bamos anteriormente.</p> <p></p> <p></p>"},{"location":"Practica5/#redireccion-forzosa-a-https","title":"Redirecci\u00f3n forzosa a HTTPS","text":"<p>Para que, indistintamente de la forma por la que accedamos al sitio web <code>balanceo</code>, siempre se fuerce a utilizar HTTPS, necesitaremos una configuraci\u00f3n adicional.</p> <p>Necesitamos a\u00f1adir un bloque <code>server</code> adicional y separado del otro, al archivo de configuraci\u00f3n de <code>balanceo</code>. Algo as\u00ed:</p> <pre><code>server {\n    listen 80;\n    server_name balanceo;\n    access_log /var/log/nginx/http_access.log;\n    return 301 https://$host$request_uri;\n}\n</code></pre> <p>Con esta configuraci\u00f3n le estamos diciendo que:</p> <ul> <li>Escuche en el puerto 80 (HTTP).</li> <li>Que el nombre al que responder\u00e1 el servidor/sitio web es <code>balanceo</code>.</li> <li>Que guarde los logs de este bloque en ese directorio y con ese nombre.</li> <li>Cuando se recibe una petici\u00f3n con las dos condiciones anteriores, se devuelve un c\u00f3digo HTTP 301:</li> </ul> <p>HTTP 301 Moved Permanently (Movido permanentemente en espa\u00f1ol) es un c\u00f3digo de estado de HTTP que indica que el host ha sido capaz de comunicarse con el servidor, pero que el recurso solicitado ha sido movido a otra direcci\u00f3n permanentemente. </p> <p>Es muy importante configurar las redirecciones 301 en los sitios web, y para ello hay diferentes m\u00e9todos y sintaxis para realizar la redirecci\u00f3n 301.</p> <p>La redirecci\u00f3n 301 es un c\u00f3digo o comando insertado por un webmaster que permite redirigir a los usuarios y buscadores de un sitio web de una direcci\u00f3n a otra.</p> <p></p>"},{"location":"Practica6/","title":"PRACTICA 3.1","text":""},{"location":"Practica6/#despliegue-manual-mediante-la-gui-de-administracion","title":"Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Realizaremos el despliegue manual de una aplicaci\u00f3n ya previamente empaquetada en formato WAR. Para ello:</p> <ol> <li>Nos logueamos con el usuario previamente creado.</li> <li>Buscamos la secci\u00f3n que nos permite desplegar un WAR manualmente, seleccionamos nuestro archivo y lo desplegamos.</li> </ol> <p></p> <p>Tras estos pasos, se nos listar\u00e1 la aplicaci\u00f3n ya desplegada como un directorio m\u00e1s y podremos acceder a ella.</p> <p>Esto detendra tomcat.</p>"},{"location":"Practica6/#despliegue-con-maven","title":"Despliegue con Maven","text":""},{"location":"Practica6/#instalacion-de-maven","title":"Instalaci\u00f3n de Maven","text":"<p>Para instalar Maven en nuestro Debian tenemos, de nuevo, dos opciones:</p> <ol> <li>Instalaci\u00f3n mediante gestor de paquetes APT</li> <li>Instalaci\u00f3n manual</li> </ol> <p>La primera, recomendada, es mucho m\u00e1s sencilla y automatizada (establece todos los paths y variables de entorno), aunque con la segunda se podr\u00eda conseguir un paquete m\u00e1s actualizado.</p> <p>Ambos m\u00e9todos vienen explicados aqu\u00ed.</p> <p>Si decidimos seguir el primer m\u00e9todo, el m\u00e1s sencillo, vemos que es tan simple como actualizar los repositorios:</p> <pre><code>sudo apt update\n</code></pre> <p>E instalar Maven:</p> <pre><code>sudo apt install maven\n</code></pre> <p>Para comprobar que todo ha ido correctamente, podemos ver la versi\u00f3n instalada de Maven:</p> <pre><code>mvn --version\n</code></pre> <p></p>"},{"location":"Practica6/#configuracion-de-maven","title":"Configuraci\u00f3n de Maven","text":"<p>Para poder realizar despliegues en nuestro Tomcat previamente instalado, necesitamos realizar la configuraci\u00f3n adecuada para Maven. Ya sabemos que esto en Linux significa editar los archivos de configuraci\u00f3n adecuados. Vamos a ello.</p> <p>En primer lugar necesitamos asegurarnos de que en el apartado anterior de la pr\u00e1ctica hemos a\u00f1adido todos los usuarios necesarios, as\u00ed como sus respectivos roles. Debemos a\u00f1adir el rol de <code>manager-script</code> para permitir que Maven se autentique contra Tomcat y pueda realizar el despliegue.</p> <p>Los roles utilizados por Tomcat vienen detallados en su documentaci\u00f3n, que merece ser consultada.</p> <p>En dicha documentaci\u00f3n se nos indica que, por temas de seguridad, es recomendable no otorgar los roles de <code>manager-script</code> o <code>manager-jmx</code> al mismo usuario que tenga el rol de <code>manager-gui</code>.</p> <p>Info: Tendremos dos usuarios, uno para la GUI y otro exclusivamente para hacer los deploys de Maven.</p> <p>As\u00ed las cosas, modificamos el archivo <code>/etc/tomcat9/tomcat-users.xml</code> (o el <code>opt/tomcat/conf/tomcat-users.xml</code> si lo instalamos desde la pagina web sehun nos indica la guia  de instalacion) acorde a nuestras necesidades (los nombres de usuario y contrase\u00f1a deber\u00e1n ser los que elij\u00e1is para vosotros):</p> <pre><code>&lt;role rolename=\"manager-gui\"/&gt;\n&lt;role rolename=\"manager-script\"/&gt;\n&lt;user username=\"gui-user\" password=\"gui-password\" roles=\"manager-gui\"/&gt;\n&lt;user username=\"script-user\" password=\"script-password\" roles=\"manager-script\"/&gt;\n</code></pre> <p></p> <p>Editar el archivo <code>/etc/maven/settings.xml</code> para indicarle a Maven, un identificador para el servidor sobre el que vamos a desplegar (no es m\u00e1s que un nombre, ponedle el nombre que consider\u00e9is), as\u00ed como las credenciales. Todo esto se har\u00e1 dentro del bloque <code>servers</code> del XML:</p> <pre><code>&lt;servers&gt;\n    &lt;server&gt;\n        &lt;id&gt;Tomcat.P.3.1&lt;/id&gt;\n        &lt;username&gt;script-user&lt;/username&gt;\n        &lt;password&gt;script-password&lt;/password&gt;\n    &lt;/server&gt;\n&lt;/servers&gt;\n</code></pre> <p></p> <p>Ahora debemos modificar el <code>POM</code> del proyecto para que haga referencia a que el despliegue se realice con el plugin de Maven para Tomcat.</p> <p>Info: No existen plugins oficiales para Tomcat m\u00e1s all\u00e1 de la versi\u00f3n 7 del servidor. No obstante, el plugin para Tomcat 7 sigue funcionando correctamente con Tomcat 9.</p> <p>Otra opci\u00f3n ser\u00eda utilizar el plugin Cargo.</p> <p>Donde lo que a\u00f1adimos es el bloque:</p> <pre><code>&lt;build&gt;\n    &lt;finalName&gt;war-deploy&lt;/finalName&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.2&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;\n                &lt;server&gt;Tomcat.P.3.1&lt;/server&gt;\n                &lt;path&gt;/myapp&lt;/path&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p></p>"},{"location":"Practica6/#despliegue","title":"Despliegue","text":"<p>Teniendo ya todo listo para realizar despliegues, ahora crearemos una aplicaci\u00f3n Java de prueba para ver si podemos desplegarla sobre la arquitectura que hemos montado. Para ello utilizamos el comando:</p> <pre><code>mvn archetype:generate -DgroupId=raul -DartifactId=war-deploy -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false\n</code></pre> <p></p> <p>Pod\u00e9is sustituir los valores de <code>groupId</code> y <code>artifactId</code> (este ser\u00e1 el nombre de la aplicaci\u00f3n) por lo que quer\u00e1is.</p> <p>Tras generar esta aplicaci\u00f3n, los comandos finales que se utilizan en Maven para desplegar, volver a desplegar o desplegar una aplicaci\u00f3n, son:</p> <pre><code>mvn tomcat7:deploy\nmvn tomcat7:redeploy\nmvn tomcat7:undeploy\n</code></pre> <p></p> <p>Y, accediendo a trav\u00e9s de la GUI, debemos ver que la aplicaci\u00f3n est\u00e1 desplegada y que podemos acceder a ella perfectamente.</p> <p></p>"},{"location":"Practica7/","title":"Pr\u00e1ctica 3.2: Despliegue de aplicaciones con Node Express","text":""},{"location":"Practica7/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta pr\u00e1ctica vamos a realizar el despliegue de aplicaciones Node.js sobre un servidor Node Express. Lo curioso de este caso es que el despliegue aqu\u00ed cambia un poco puesto que no se hace sobre el servidor, sino que la aplicaci\u00f3n es el servidor.</p> <p>Warning</p> <p>Comprueba que el servidor Tomcat de pr\u00e1cticas anteriores no est\u00e1 corriendo o nos dar\u00e1 problemas:</p> <p><code>bash sudo systemctl status tomcat9</code></p> <p>Y en caso de salir activo, pararlo:</p> <p><code>bash sudo systemctl stop tomcat9</code></p> <p>Si no lo has instalado mediante APT, deber\u00e1s ir al directorio donde lo tengas. En mi caso es <code>/opt/tomcat</code> y hacer:</p> <pre><code>cd /opt/tomcat/bin\n./shutdown.sh\n</code></pre> <p></p>"},{"location":"Practica7/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>La primera parte de la pr\u00e1ctica es muy sencilla. Consistir\u00e1 en instalar sobre nuestra Debian 11 tanto Node.js como Express y tras ello crear un archivo <code>.js</code> de prueba para comprobar que nuestro primer despliegue funciona correctamente.</p> <p>Para ello, os pod\u00e9is apoyar en este sencillo tutorial o este otro, Y para Express:</p> <p>En lugar de acceder a <code>http://localhost:3000</code>, deb\u00e9is acceder desde vuestra m\u00e1quina local a <code>http://IP-maq-virtual:3000</code>, utilizando la IP concreta de vuestra m\u00e1quina virtual.</p> <p>Recordatorio</p> <p>Deb\u00e9is a\u00f1adir a vuestro grupo de seguridad el puerto que est\u00e9is utilizando para acceder a la aplicaci\u00f3n (3000 u otro), permitiendo el tr\u00e1fico de entrada hacia ese puerto TCP.</p> <p>Recordad parar el servidor (<code>CTRL+C</code>) al acabar la pr\u00e1ctica.</p>"},{"location":"Practica7/#task","title":"Task","text":"<p>Documenta, incluyendo capturas de pantallas, el proceso que has seguido para realizar el despliegue de esta nueva aplicaci\u00f3n, as\u00ed como el resultado final.</p>"},{"location":"Practica7/#instalacion-de-nodejs-y-express-en-debian-11","title":"Instalaci\u00f3n de Node.js y Express en Debian 11","text":"<p>Para comenzar, abre una terminal y actualiza el sistema operativo:</p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p></p> <p>Luego, a\u00f1ade el repositorio de la rama 16.x de NodeJS:</p> <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n</code></pre> <p></p> <p>Despu\u00e9s, ejecuta el siguiente comando:</p> <pre><code>sudo apt install nodejs\n</code></pre> <p></p> <p>Finalmente, verifica las versiones instaladas de NodeJS y NPM para asegurarte de que la instalaci\u00f3n fue exitosa:</p> <pre><code>node --version\nv16.13.2\nnpm --version\n8.1.2\n</code></pre> <p></p>"},{"location":"Practica7/#instalando-expressjs-en-debian-11","title":"Instalando ExpressJS en Debian 11","text":"<p>Ahora es momento de instalar Express.js. Para hacerlo de manera global, ejecuta:</p> <pre><code>sudo npm install -g express\n</code></pre> <p></p>"},{"location":"Practica7/#1-instalando-expressjs-en-debian-11","title":"1. Instalando ExpressJS en Debian 11","text":"<p>Primero, crea una carpeta para el proyecto:</p> <pre><code>mkdir project\n</code></pre> <p>Accede a la carpeta:</p> <pre><code>cd project\n</code></pre> <p>Inicializa el proyecto:</p> <pre><code>npm init -y\n</code></pre> <p></p> <p>Instala Express.js localmente para este proyecto:</p> <pre><code>npm install express\n</code></pre> <p>Crea un archivo de ejemplo:</p> <pre><code>sudo nano app.js\n</code></pre> <p></p> <p>Agrega el siguiente contenido:</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Hola. Bienvenido a este blog')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Aplicaci\u00f3n de ejemplo escuchando en http://localhost:${port}`)\n})\n</code></pre> <p></p>"},{"location":"Practica7/#2-creando-una-nueva-aplicacion-con-expressjs","title":"2. Creando una nueva aplicaci\u00f3n con Express.js","text":"<p>Guarda los cambios y cierra el editor.</p> <p>Ejecuta el proyecto con este comando:</p> <pre><code>node app.js\n</code></pre> <p>Salida de ejemplo:</p> <pre><code>Aplicaci\u00f3n de ejemplo escuchando en http://localhost:3000\n</code></pre> <p> </p>"},{"location":"Practica7/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Vamos ahora a realizar el despliegue de una aplicaci\u00f3n de terceros para ver c\u00f3mo es el proceso.</p> <p>Se trata de un \"prototipo\" de una aplicaci\u00f3n de predicci\u00f3n meteorol\u00f3gica que pod\u00e9is encontrar en este repositorio de Github.</p> <p>Tal y como indican las instrucciones del propio repositorio, los pasos a seguir son, en primer lugar, clonar el repositorio a nuestra m\u00e1quina:</p> <pre><code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application\n</code></pre> <p>Movernos al nuevo directorio:</p> <pre><code>cd Shopping-Cart-Application/\n</code></pre> <p>Instalar las librer\u00edas necesarias (paciencia, este proceso puede tardar un buen rato):</p> <pre><code>npm install\n</code></pre> <p></p> <p>Y, por \u00faltimo, iniciar la aplicaci\u00f3n:</p> <pre><code>npm run start\n</code></pre> <p>Cuando sig\u00e1is el proceso necesario e intent\u00e9is iniciar la aplicaci\u00f3n con Express, os dar\u00e1 un error del tipo:</p> <pre><code>sh: 1: nodemon: not found\n</code></pre> <p></p> <p>Este error ocurre porque no tenemos instalado el nodemon. para arreglarlo podemos instalarlo globalmente o solo en el proyecto. en mi caso lo hare en el proyecto</p> <p>para eso tenemos que usar el siguiente comando dentro del proyecto:</p> <pre><code>npm install nodemon --save-dev\n</code></pre> <p> </p>"},{"location":"Practica7/#practica-34","title":"PRACTICA 3.4","text":"<p>Tras loguearnos por SSH en nuestro Debian, nos crearemos un directorio para albergar la aplicaci\u00f3n con el nombre que queramos. En ese directorio, crearemos los 3 archivos (dos .html y un .js) que conformar\u00e1n nuestra sencilla aplicaci\u00f3n de ejemplo:</p> <ul> <li>head.html</li> <li>tail.html</li> <li>aplicacion.js</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Esta es la pagina principal&lt;/h1&gt;\n    &lt;p&gt;&lt;a href=\"/tailPage\"&gt;Ir a la siguiente pagina&lt;/a&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Esta es la pagina principal&lt;/h1&gt;\n    &lt;p&gt;&lt;a href=\"/tailPage\"&gt;Ir a la siguiente pagina&lt;/a&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>var http = require('http');\nvar fs = require('fs'); // para obtener los datos del archivo html\nvar port = process.env.PORT || 8080; \n\nhttp.createServer(function (req, res) {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n\n    // req.url almacena el path o ruta de la URL\n    var url = req.url;\n    if (url === \"/\") {\n// fs.readFile busca el archivo HTML\n// el primer par\u00e1metro es el path al archivo HTML\n// y el segundo es el callback de la funci\u00f3n\n// si el archivo no se encuentra, la funci\u00f3n devuelve un error\n// si el archivo se encuentra, el contenido del mismo se encuentra en pgres    \n        fs.readFile(\"head.html\", function (err, pgres) {\n            if (err)\n                res.write(\"HEAD.HTML NOT FOUND\");\n            else {\n                // Las siguientes 3 lineas\n                // tienen la funci\u00f3n de enviar el archivo html\n                // y finalizar el proceso de respuesta\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n    else if (url === \"/tailPage\") {\n        fs.readFile(\"tail.html\", function (err, pgres) {\n            if (err)\n                res.write(\"TAIL.HTML NOT FOUND\");\n            else {\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n\n}).listen(port, function () {\n    console.log(\"SERVER STARTED PORT: 8080\");\n});\n</code></pre> <p> Ahora, tal y como hacemos siempre a la hora de crear nuestra aplicaci\u00f3n Node.js, con el fin de crear el archivo package.json, utilizaremos en el terminal el comando:</p> <pre><code>npm init\n</code></pre> <p> Podemos probar que nuestra aplicaci\u00f3n funciona perfectamente en local:</p> <pre><code>node aplicacion.js\n</code></pre> <p> Y tras ello, debemos poder acceder, desde nuestra m\u00e1quina anfitriona a <code>http://IP-maq-virtual:8080</code></p> <p>Ya con la aplicaci\u00f3n creada y comprobada, podremos desplegarla en m\u00faltiples plataformas en la nube, como AWS, GCP, Azure, Digital Ocean, Heroku...</p> <p>Warning</p> <p>Para que nos funcione en la plataforma PaaS, en el archivo package.json que se nos ha creado al hacer el npm init debemos hacerle una modificaci\u00f3n.</p> <p>En el bloque scripts, debemos borrar lo que haya dentro y dejar \u00fanicamente dentro de \u00e9l:</p> <p><code>json \"start\": \"node aplicacion.js\"</code></p> <p>De forma que el sitio donde la despleguemos sepa que comando utilizar para iniciar la aplicaci\u00f3n tras desplegarla.</p>"},{"location":"Practica7/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Puesto que el inter\u00e9s en este m\u00f3dulo radica en el proceso de despliegue, suponiendo que la parte de desarrollo ya es abordada en otros m\u00f3dulos, vamos a utilizar una aplicaci\u00f3n de ejemplo que nos ahorre tiempo para centrarnos en el despliegue.</p> <p>Nos clonaremos este repositorio:</p> <pre><code>git clone https://github.com/StackAbuse/color-shades-generator\n</code></pre> <p></p>"},{"location":"Practica7/#proceso-de-despliegue-en-netlify","title":"Proceso de despliegue en Netlify","text":"<p>Por mera curiosidad y ambici\u00f3n de aprendizaje, vamos a ver dos m\u00e9todos de despliegue en Netlify:</p> <ol> <li>Despliegue manual desde el CLI de Netlify, es decir, desde el terminal, a partir de un directorio local de nuestra m\u00e1quina.</li> <li>Despliegue desde un c\u00f3digo publicado en uno de nuestros repositorios de Github</li> </ol> <p>El primero nos permitir\u00e1 conocer el CLI de Netlify y el segundo nos acercara m\u00e1s a una experiencia real de despliegue.</p>"},{"location":"Practica7/#task_1","title":"Task","text":"<p>Vuestra primera tarea ser\u00e1 registraros en Netlify con vuestro email (no con vuestra cuenta de Github) y decirle que no cuando os pida enlazar con vuestra cuenta de Github (lo haremos m\u00e1s adelante).</p>"},{"location":"Practica7/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Una vez registrados, debemos instalar el CLI de Netlify para ejecutar sus comandos desde el terminal:</p> <pre><code>sudo npm install netlify-cli -g\n</code></pre> <p></p> <p>Est\u00e1 claro que para realizar acciones de deploy, Netlify nos solicitar\u00e1 una autenticaci\u00f3n, esto se hace mediante el comando:</p> <pre><code>netlify login\n</code></pre> <p> El cual nos muestra una pantalla del navegador para que concedamos la autorizaci\u00f3n pertinente. Sin embargo, recordemos el problema de que estamos conectados por SSH a nuestro servidor y no tenemos la posibilidad del uso de un entorno gr\u00e1fico.</p> <p>En este caso, siguiendo las instrucciones de la documentaci\u00f3n:</p> <p>Generamos el token de acceso   Lo establecemos como variable de ambiente:</p> <p>Y nos logueamos</p> <pre><code>netlify login\n</code></pre> <p></p> <p>Bueno, tenemos el c\u00f3digo de nuestra aplicaci\u00f3n, tenemos nuestra cuenta en Netlify y tenemos el CLI necesario para ejecutar comandos desde el terminal en esa cuenta... \u00bfPodemos proceder al despliegue sin mayores complicaciones?</p> <p>La respuesta es NO, como buenos desarrolladores y en base a experiencias anteriores, ya sab\u00e9is que hay que hacer un build de la aplicaci\u00f3n para, posteriormente, desplegarla. Vamos a ello.</p> <p>En primer lugar, como sabemos, debemos instalar todas las dependencias que vienen indicadas en el archivo package.json:</p> <pre><code>npm install\n</code></pre> <p> Y cuando ya las tengamos instaladas podemos proceder a realizar el build:</p> <pre><code>npm run build\n</code></pre> <p> Esto nos crear\u00e1 una nueva carpeta llamada build que contendr\u00e1 la aplicaci\u00f3n que debemos desplegar. Y ya podemos hacer un pre-deploy de la aplicaci\u00f3n de la que hemos hecho build antes:</p> <pre><code>netlify deploy\n</code></pre> <p> Nos har\u00e1 algunas preguntas para el despliegue: - Indicamos que queremos crear y configurar un nuevo site - El Team lo dejamos por defecto - Le indicamos el nombre que queremos emplear para la web (nombre-practica3-4) y el directorio a utilizar para el deploy (directorio ./build).</p> <p>Y si nos indica que todo ha ido bien e incluso podemos ver el \"borrador\" (Website Draft URL) de la web que nos aporta, podemos pasarla a producci\u00f3n finalmente tal y como nos indica la misma salida del comando:</p> <pre><code>If everything looks good on your draft URL, deploy it to your main site URL with the --prod flag.\nnetlify deploy --prod\n</code></pre> <p></p> <p>Warning</p> <p>No olvides desplegar finalmente en producci\u00f3n y comprobar que puedes acceder a la URL.</p>"},{"location":"Practica7/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>En primer lugar, vamos a eliminar el site que hemos desplegado antes en Netlify para evitarnos cualquier problema y/o conflicto:</p> <p>En segundo lugar, vamos a borrar el directorio donde se halla el repositorio clonado en el paso anterior para as\u00ed poder empezar de 0:</p> <pre><code>rm -rf directorio_repositorio\n</code></pre> <p>Como queremos simular que hemos picado el c\u00f3digo a mano en local y lo vamos a subir a Github por primera vez, nos descargaremos los fuentes en formato .zip sin que tenga ninguna referencia a Github:</p> <pre><code>wget https://github.com/StackAbuse/color-shades-generator/archive/refs/heads/main.zip\n</code></pre> <p>Creamos una carpeta nueva y descomprimimos dentro el zip:</p> <pre><code>mkdir practica3.4\nunzip main.zip -d practica3.4/\n</code></pre> <p></p> <p>Entramos en la carpeta donde est\u00e1 el c\u00f3digo:</p> <pre><code>cd practica3.4/color-shades-generator-main/\n</code></pre> <p>Ahora debemos crear un repositorio completamente vac\u00edo en Github que se llame practicaTresCuatro:</p> <p> Y tras ello, volviendo al terminal a la carpeta donde est\u00e1bamos, la iniciamos como repositorio, a\u00f1adimos todo el contenido de la misma para el commit, hacemos el commit con el mensaje correspondiente y creamos la rama main:</p> <pre><code>$ git init\n$ git add .\n$ git commit -m \"Subiendo el c\u00f3digo...\"\n$ git branch -M main\n</code></pre> <p>Y ahora s\u00f3lo queda referenciar nuestra carpeta al repositorio reci\u00e9n creado en Github y hacer un push para subir todo el contenido del commit a \u00e9l:</p> <pre><code>$ git remote add origin https://github.com/username/practicaTresCuatro.git\n$ git push -u origin main\n</code></pre> <p> Ahora que ya tenemos subido el c\u00f3digo a GitHub, de alguna manera debemos enganchar o enlazar nuestra cuenta de Github con la de Netlify para que \u00e9ste \u00faltimo pueda traerse el c\u00f3digo de all\u00ed, hacer el build y desplegarlo. As\u00ed pues, entramos en nuestro dashboard de Netlify y le damos a importar proyecto existente de git:</p> <p>Le indicamos que concretamente de Github:</p> <p>Y nos saltar\u00e1 una ventana pidiendo que autoricemos a Netlify a acceder a nuestros repositorios de Github:</p> <p></p> <p>Y luego le indicaremos que no acceda a todos nuestros repositorios sino s\u00f3lo al repositorio que necesitamos, que es donde tenemos el c\u00f3digo de nuestra aplicaci\u00f3n:  Y ya quedar\u00e1 todo listo:  Y desplegamos la aplicaci\u00f3n:</p> <p>Netlify se encargar\u00e1 de hacer el build de forma autom\u00e1tica tal y como hemos visto en la imagen de arriba, con el comando npm run build, publicando el contenido del directorio build.</p> <p>Atenci\u00f3n</p> <p>Tras el deploy, en \"Site settings\" pod\u00e9is y deb\u00e9is cambiar el nombre de la aplicaci\u00f3n por nombre-practica3-4, donde nombre es vuestro nombre.</p> <p></p> <p>Lo que hemos conseguido de esta forma es que, cualquier cambio que hagamos en el proyecto y del que hagamos commit y push en Github, autom\u00e1ticamente genere un nuevo despliegue en Netlify. Es el principio de lo que m\u00e1s adelante veremos como despliegue continuo.</p> <p>Comprobemos que realmente es as\u00ed:</p> <p>Dentro de la carpeta public encontramos el archivo robots.txt, cuyo cometido es indicar a los rastreadores de los buscadores a qu\u00e9 URLs del sitio pueden acceder. A este archivo se puede acceder a trav\u00e9s de la URL del site:</p> <p>Dentro de la carpeta public, utilizando el editor de texto que prefir\u00e1is en vuestro terminal, modificad el archivo robots.txt para que excluya un directorio que se llame nombre_apellido, utilizando obviamente vuestro nombre y apellido.</p> <p></p> <pre><code>User-agent: *\nDisallow: /nombre_y_apellido/\n</code></pre> <p> Haz un nuevo commit y push (del caso anterior, recuerda el comando git previo para a\u00f1adir los archivos a hacer commit)</p> <p></p> <p>Comprueba en el dashboard de Netlify que se ha producido un nuevo deploy de la aplicaci\u00f3n hace escasos segundos  Accede a <code>https://url_de_la_aplicacion/robots.txt</code> y comprueba que, efectivamente, se ve reflejado el cambio </p>"},{"location":"Practica8/","title":"Procedimiento completo para el despliegue","text":""},{"location":"Practica8/#instalacion-de-pip","title":"Instalaci\u00f3n de pip","text":"<p>Instalamos el gestor de paquetes de Python pip:</p> <pre><code>sudo apt update\nsudo apt install python3-pip\n</code></pre> <p></p>"},{"location":"Practica8/#instalacion-de-pipenv","title":"Instalaci\u00f3n de pipenv","text":"<p>Instalamos el paquete pipenv para gestionar los entornos virtuales:</p> <pre><code>sudo apt install pipenv\n</code></pre> <p></p> <p>Y comprobamos que est\u00e1 instalado correctamente mostrando su versi\u00f3n:</p> <pre><code>pipenv --version\n</code></pre> <p></p>"},{"location":"Practica8/#creacion-del-directorio-del-proyecto","title":"Creaci\u00f3n del directorio del proyecto","text":"<p>Creamos el directorio en el que almacenaremos nuestro proyecto:</p> <pre><code>sudo mkdir /var/www/nombre_mi_aplicacion\n</code></pre> <p>Al crearlo con <code>sudo</code>, los permisos pertenecen a root. Hay que cambiarlo para que el due\u00f1o sea nuestro usuario (raul-debian en mi caso) y pertenezca al grupo <code>www-data</code>, el usuario usado por defecto por el servidor web para correr:</p> <pre><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion\n</code></pre> <p>Establecemos los permisos adecuados a este directorio, para que pueda ser le\u00eddo por todo el mundo:</p> <pre><code>chmod -R 775 /var/www/mi_aplicacion\n</code></pre> <p></p> <p>Warning</p> <p>Es indispensable asignar estos permisos, de otra forma obtendr\u00edamos un error al acceder a la aplicaci\u00f3n cuando pongamos en marcha Nginx.</p>"},{"location":"Practica8/#creacion-del-archivo-env","title":"Creaci\u00f3n del archivo .env","text":"<p>Dentro del directorio de nuestra aplicaci\u00f3n, creamos un archivo oculto <code>.env</code> que contendr\u00e1 las variables de entorno necesarias:</p> <pre><code>touch .env\n</code></pre> <p></p> <p>Editamos el archivo y a\u00f1adimos las variables, indicando cu\u00e1l es el archivo <code>.py</code> de la aplicaci\u00f3n y el entorno, que en nuestro caso ser\u00e1 producci\u00f3n. </p> <p>Nota</p> <p>En el mundo laboral real, se supone que la aplicaci\u00f3n previamente ha pasado por los entornos de dev, test y preprod para el desarrollo y prueba de la misma, antes de pasarla a producci\u00f3n.</p>"},{"location":"Practica8/#iniciar-el-entorno-virtual","title":"Iniciar el entorno virtual","text":"<p>Iniciamos ahora nuestro entorno virtual. Pipenv cargar\u00e1 las variables de entorno desde el fichero <code>.env</code> de forma autom\u00e1tica:</p> <pre><code>pipenv shell\n</code></pre> <p></p> <p>Veremos que se nos inicia el entorno virtual, cosa que comprobamos porque aparece su nombre al inicio del prompt del shell.</p>"},{"location":"Practica8/#instalacion-de-dependencias","title":"Instalaci\u00f3n de dependencias","text":"<p>Usamos pipenv para instalar las dependencias necesarias para nuestro proyecto:</p> <pre><code>pipenv install flask gunicorn\n</code></pre> <p></p>"},{"location":"Practica8/#creacion-de-la-aplicacion-flask","title":"Creaci\u00f3n de la aplicaci\u00f3n Flask","text":"<p>Vamos ahora a crear la aplicaci\u00f3n Flask m\u00e1s simple posible, a modo de PoC (proof of concept o prueba de concepto). El archivo que contendr\u00e1 la aplicaci\u00f3n propiamente dicha ser\u00e1 <code>application.py</code> y <code>wsgi.py</code> se encargar\u00e1 \u00fanicamente de iniciarla y dejarla corriendo:</p> <pre><code>touch application.py wsgi.py\n</code></pre> <p>Y tras crear los archivos, los editamos para dejarlos as\u00ed. </p>"},{"location":"Practica8/#comprobacion-de-la-aplicacion-flask","title":"Comprobaci\u00f3n de la aplicaci\u00f3n Flask","text":"<p>Corramos ahora nuestra aplicaci\u00f3n a modo de comprobaci\u00f3n con el servidor web integrado de Flask. Si especificamos la direcci\u00f3n <code>0.0.0.0</code> lo que le estamos diciendo al servidor es que escuche en todas sus interfaces, si las tuviera.</p> <p>Ahora podremos acceder a la aplicaci\u00f3n desde nuestro ordenador, nuestra m\u00e1quina anfitri\u00f3n, introduciendo en un navegador web: <code>http://IP-maq-virtual:5000</code>.</p> <p>Tras la comprobaci\u00f3n, paramos el servidor con <code>CTRL+C</code>.</p> <p> </p> <p>Recordatorio</p> <p>Habr\u00e1s de abrir el puerto correspondiente en el grupo de seguridad.</p>"},{"location":"Practica8/#comprobacion-de-gunicorn","title":"Comprobaci\u00f3n de Gunicorn","text":"<p>Comprobemos ahora que Gunicorn funciona correctamente tambi\u00e9n. Si os ha funcionado el servidor de desarrollo de Flask, pod\u00e9is usar el siguiente comando para probar que la aplicaci\u00f3n funciona correctamente usando Gunicorn, accediendo con vuestro navegador de la misma forma que en el paso anterior:</p> <pre><code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app\n</code></pre> <p>Donde: - <code>--workers N</code> establece el n\u00famero de workers o hilos que queremos utilizar, como ocurr\u00eda con Node Express. Depender\u00e1 del n\u00famero de cores que le hayamos dado a la CPU de nuestra m\u00e1quina virtual. - <code>--bind 0.0.0.0:5000</code> hace que el servidor escuche peticiones por todas sus interfaces de red y en el puerto 5000. - <code>wsgi:app</code> es el nombre del archivo con extensi\u00f3n <code>.py</code> y <code>app</code> es la instancia de la aplicaci\u00f3n Flask dentro del archivo.</p> <p></p> <p>Todav\u00eda dentro de nuestro entorno virtual, debemos tomar nota de cu\u00e1l es el path o ruta desde la que se ejecuta gunicorn para poder configurar m\u00e1s adelante un servicio del sistema. Podemos averiguarlo as\u00ed: </p> <p>Tip</p> <p>Y tras ello debemos salir de nuestro entorno virtual con el sencillo comando <code>deactivate</code>.</p> <p></p>"},{"location":"Practica8/#iniciar-nginx","title":"Iniciar Nginx","text":"<p>Puesto que ya debemos tener instalado Nginx en nuestro sistema, lo iniciamos y comprobamos que su estado sea activo:</p> <pre><code>sudo systemctl start nginx\nsudo systemctl status nginx\n</code></pre> <p></p>"},{"location":"Practica8/#creacion-del-servicio-systemd","title":"Creaci\u00f3n del servicio systemd","text":"<p>Ya fuera de nuestro entorno virtual, crearemos un archivo para que systemd corra Gunicorn como un servicio del sistema m\u00e1s.</p> <p>Donde: - <code>User</code>: Establece el usuario que tiene permisos sobre el directorio del proyecto (el que pusist\u00e9is en el paso 5). - <code>Group</code>: Establece el grupo que tiene permisos sobre el directorio del proyecto (el que pusist\u00e9is en el paso 5). - <code>Environment</code>: Establece el directorio bin (donde se guardan los binarios ejecutables) dentro del entorno virtual (lo visteis en el paso 14). - <code>WorkingDirectory</code>: Establece el directorio base donde reside nuestro proyecto. - <code>ExecStart</code>: Establece el path donde se encuentra el ejecutable de gunicorn dentro del entorno virtual, as\u00ed como las opciones y comandos con los que se iniciar\u00e1.</p> <p></p> <p>Warning</p> <p>Deb\u00e9is cambiar los valores para que coincidan con los de vuestro caso particular.</p> <p>Ahora, como cada vez que se crea un servicio nuevo de systemd, se habilita y se inicia:</p> <pre><code>systemctl enable nombre_mi_servicio\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>Recordad que el nombre del servicio es el nombre del archivo que creasteis en el paso anterior.</p>"},{"location":"Practica8/#configuracion-de-nginx","title":"Configuraci\u00f3n de Nginx","text":"<p>Pasemos ahora a configurar Nginx, que es algo que ya deber\u00edamos tener dominado de cap\u00edtulos anteriores.</p> <p>Creamos un archivo con el nombre de nuestra aplicaci\u00f3n y dentro estableceremos la configuraci\u00f3n para ese sitio web. El archivo, como record\u00e1is, debe estar en <code>/etc/nginx/sites-available/nombre_aplicacion</code> y tras ello lo editamos para que quede:</p> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion;\n\n    access_log /var/log/nginx/mi_aplicacion.access.log;\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock;\n    }\n}\n</code></pre> <p></p> <p>Recordemos que ahora debemos crear un link simb\u00f3lico del archivo de sitios webs disponibles al de sitios web activos:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/\n</code></pre> <p>Y nos aseguramos de que se ha creado dicho link simb\u00f3lico:</p> <pre><code>ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion\n</code></pre> <p>Nos aseguramos de que la configuraci\u00f3n de Nginx no contiene errores, reiniciamos Nginx y comprobamos que su estado es activo:</p> <pre><code>nginx -t\nsudo systemctl restart nginx\nsudo systemctl status nginx\n</code></pre> <p></p> <p>Ya no podremos acceder por IP a nuestra aplicaci\u00f3n ya que ahora est\u00e1 siendo servida por Gunicorn y Nginx, necesitamos acceder por su <code>server_name</code>. Puesto que a\u00fan no hemos tratado con el DNS, vamos a editar el archivo <code>/etc/hosts</code> de nuestra m\u00e1quina anfitriona para que asocie la IP de la m\u00e1quina virtual, a nuestro <code>server_name</code>.</p> <p>Este archivo, en Linux, est\u00e1 en: <code>/etc/hosts</code>.</p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>.</p> <p>Y deberemos a\u00f1adirle la l\u00ednea:</p> <pre><code>192.168.X.X myproject www.myproject\n</code></pre> <p>donde deb\u00e9is sustituir la IP por la que tenga vuestra m\u00e1quina virtual.</p> <p></p> <p>El \u00faltimo paso es comprobar que todo el desplieuge se ha realizado de forma correcta y est\u00e1 funcionando, para ello accedemos desde nuestra m\u00e1quina anfitri\u00f3n a:</p> <p>http://nombre_aplicacion</p> <p>O:</p> <p>http://www.nombre_aplicacion</p> <p>Y deber\u00eda mostraros la misma p\u00e1gina que en el paso 14:</p> <p></p>"},{"location":"Practica8/#cuestiones","title":"Cuestiones","text":""},{"location":"Practica8/#cuestion-1","title":"Cuestion 1","text":"<p>Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI</p> <p>Un servidor WSGI (Web Server Gateway Interface) es una interfaz est\u00e1ndar que conecta aplicaciones web escritas en Python con servidores web como Apache o Nginx. Act\u00faa como intermediario, recibiendo solicitudes HTTP del servidor y pas\u00e1ndolas a la aplicaci\u00f3n Python para su procesamiento, y luego devolviendo las respuestas al cliente. Es esencial para ejecutar aplicaciones Python en producci\u00f3n, garantizando compatibilidad entre servidores y frameworks, adem\u00e1s de ofrecer escalabilidad y eficiencia</p>"},{"location":"Practica9/","title":"Pr\u00e1ctica 4.1 - Configuraci\u00f3n de un servidor DNS","text":""},{"location":"Practica9/#instalacion-de-servidor-dns","title":"Instalaci\u00f3n de servidor DNS","text":"<p>Para instalar el servidor DNS en Ubuntu podemos instalarlo como cualquier paquete en Ubuntu:</p> <pre><code>sudo apt-get install bind9 bind9utils bind9-doc\n</code></pre> <p></p>"},{"location":"Practica9/#configuracion-del-servidor","title":"Configuraci\u00f3n del servidor","text":"<p>Puesto que en clase s\u00f3lo vamos a utilizar IPv4, en su archivo general de configuraci\u00f3n  named que se encuentra en el directorio:</p> <p><code>/etc/default</code> </p> <p>Y para indicarle que s\u00f3lo use IPv4, debemos modificar esto:</p> <pre><code>OPTIONS = \"-u bind -4\"\n</code></pre> <p></p> <p>El archivo de configuraci\u00f3n principal named.conf de Bind est\u00e1 en el directorio:</p> <p><code>/etc/bind</code> </p> <p></p>"},{"location":"Practica9/#configuracion-namedconfoptions","title":"Configuraci\u00f3n named.conf.options","text":"<p>Usamos este comando para hacer una copia de seguridad </p> <pre><code>sudo cp /etc/bind/named.conf.options /etc/bind/named.conf.options.backup\n</code></pre> <p></p> <p>Ahora editaremos el archivo named.conf.options e incluiremos los siguientes contenidos:</p> <p></p> <p></p> <p>Podemos comprobar si nuestra configuraci\u00f3n es correcta con el comando:</p> <pre><code>sudo named-checkconf\n</code></pre> <p>Si hay alg\u00fan error aparecera a la hora de ejecutar el comando, si no nos devuelve a la l\u00ednea de comandos.</p> <p>Reiniciamos el servidor y comprobamos su estado:</p> <pre><code>sudo systemctl restart bind9\nsudo systemctl status bind9\n</code></pre> <p></p>"},{"location":"Practica9/#configuracion-namedconflocal","title":"Configuraci\u00f3n named.conf.local","text":"<p>En este archivo configuraremos aspectos relativos a nuestras zonas. Vamos a declarar la zona \u201cdeaw.es\u201d. </p> <p></p>"},{"location":"Practica9/#creacion-del-archivo-de-zona","title":"Creaci\u00f3n del archivo de zona","text":"<p>Creamos el archivo de la zona directa en el directorio que le hemos especificado antes.</p> <p></p> <p>El contenido ser\u00e1 algo as\u00ed (respetar el formato):</p> <p></p>"},{"location":"Practica9/#creacion-del-archivo-de-zona-para-la-resolucion-inversa","title":"Creaci\u00f3n del archivo de zona para la resoluci\u00f3n inversa","text":"<p>Ahora se tiene que crear el archivo de la resolucion inversa, para ello en el mismo lugar que en la zona direxta se pone esto</p> <p></p> <p>Donde la X es el tercer byte de la red de la maquina.</p> <p>Y se crea el archivo correspondiente con su configuracion:</p> <p> </p>"},{"location":"Practica9/#comprobacion-de-las-configuraciones","title":"Comprobaci\u00f3n de las configuraciones","text":"<p>Para comprobar la configuraci\u00f3n de la zona de resoluci\u00f3n directa:</p> <pre><code>sudo named-checkzone deaw.es /etc/bind/db.deaw.es\n</code></pre> <p>Y para comprobar la configuraci\u00f3n de la zona de resoluci\u00f3n inversa:</p> <pre><code>sudo named-checkzone X.168.192.in-addr.arpa /etc/bind/db.X.168.192\n</code></pre> <p>Si todo est\u00e1 bien, devolver\u00e1 OK. </p> <p></p> <p>Reiniciamos el servicio y comprobamos el estado:</p> <pre><code>sudo systemctl restart bind9\nsudo systemctl status bind9\n</code></pre> <p></p>"},{"location":"Practica9/#atencion","title":"Atenci\u00f3n","text":"<p>Es muy importante que el cliente est\u00e9 configurado para usar como servidor DNS el que acabamos de instalar y  configurar. Ya sea Windows, ya sea Linux, deb\u00e9is cambiar vuestra configuraci\u00f3n de red para que la m\u00e1quina con la  que hag\u00e1is las pruebas utilice este servidor DNS como el principal.</p> <p></p>"},{"location":"Practica9/#comprobacion-de-las-resoluciones-y-de-las-consultas","title":"Comprobaci\u00f3n de las resoluciones y de las consultas","text":"<p>Podemos comprobar desde los clientes, con <code>dig</code> o <code>nslookup</code> las resoluciones directas e inversas en mi caso usare nslookup.</p> <p></p>"},{"location":"Practica9/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"Practica9/#cuestion-1-que-pasara-si-un-cliente-de-una-red-diferente-a-la-tuya-intenta-hacer-uso-de-tu-dns-de-alguna-manera-le-funcionara-por-que-en-que-parte-de-la-configuracion-puede-verse","title":"Cuesti\u00f3n 1 \u00bfQu\u00e9 pasar\u00e1 si un cliente de una red diferente a la tuya intenta hacer uso de tu DNS de alguna manera, le funcionar\u00e1? \u00bfPor qu\u00e9, en qu\u00e9 parte de la configuraci\u00f3n puede verse?","text":"<p>No le funcionar\u00e1 porque en la configuraci\u00f3n del servidor DNS se especifican las redes o clientes  que tienen permitido hacer consultas. Esto se define en la ACL (allow-query en el archivo named.conf.options).  Si una IP o red no est\u00e1 incluida en esta lista, las consultas ser\u00e1n rechazadas.</p>"},{"location":"Practica9/#cuestion-2-por-que-tenemos-que-permitir-las-consultas-recursivas-en-la-configuracion","title":"Cuesti\u00f3n 2 \u00bfPor qu\u00e9 tenemos que permitir las consultas recursivas en la configuraci\u00f3n?","text":"<p>Las consultas recursivas permiten que el servidor DNS resuelva nombres de dominio que no est\u00e1n definidos en sus zonas configuradas localmente. Esto es \u00fatil para que los clientes puedan acceder a dominios externos como google.com a trav\u00e9s de nuestro servidor. Sin consultas recursivas, el servidor solo responder\u00eda consultas sobre las zonas para las que es autoritativo.</p>"},{"location":"Practica9/#cuestion-3-el-servidor-dns-que-acabais-de-montar-es-autoritativo-por-que","title":"Cuesti\u00f3n 3 \u00bfEl servidor DNS que acab\u00e1is de montar, es autoritativo? \u00bfPor qu\u00e9?","text":"<p>S\u00ed, es autoritativo para las zonas configuradas espec\u00edficamente (como deaw.es).  Un servidor es autoritativo si tiene los datos originales de la zona y puede proporcionar respuestas definitivas para los nombres en esa zona. Esto se configura en los archivos de zona directa e inversa.</p>"},{"location":"Practica9/#cuestion-4-donde-podemos-encontrar-la-directiva-origin-y-para-que-sirve","title":"Cuesti\u00f3n 4 \u00bfD\u00f3nde podemos encontrar la directiva $ORIGIN y para qu\u00e9 sirve?","text":"<p>La directiva $ORIGIN se encuentra en los archivos de zona y se utiliza para establecer un dominio base  para los registros que se definen despu\u00e9s de ella. Si no se especifica un dominio completo en un registro, se a\u00f1ade autom\u00e1ticamente el valor de $ORIGIN. Por defecto, $ORIGIN toma el nombre de la zona configurada.</p>"},{"location":"Practica9/#cuestion-5-una-zona-es-identico-a-un-dominio","title":"Cuesti\u00f3n 5 \u00bfUna zona es id\u00e9ntico a un dominio?","text":"<p>No, una zona es una parte de un dominio que est\u00e1 bajo la administraci\u00f3n de un servidor DNS. Un dominio puede estar compuesto por m\u00faltiples zonas. </p>"},{"location":"Practica9/#cuestion-6-pueden-editarse-los-archivos-de-zona-de-un-servidor-esclavosecundario","title":"Cuesti\u00f3n 6 \u00bfPueden editarse los archivos de zona de un servidor esclavo/secundario?","text":"<p>No, los archivos de zona de un servidor esclavo no pueden editarse directamente porque estos son copias sincronizadas autom\u00e1ticamente desde el servidor maestro. Cualquier cambio debe hacerse en el servidor maestro, y el esclavo actualizar\u00e1 sus datos mediante transferencia de zona.</p>"},{"location":"Practica9/#cuestion-7-por-que-podria-querer-tener-mas-de-un-servidor-esclavo-para-una-misma-zona","title":"Cuesti\u00f3n 7 \u00bfPor qu\u00e9 podr\u00eda querer tener m\u00e1s de un servidor esclavo para una misma zona?","text":"<p>Tener m\u00e1s de un servidor esclavo proporciona redundancia y mejora la disponibilidad del servicio DNS.  Si el servidor maestro o uno de los esclavos falla, los clientes a\u00fan pueden resolver nombres utilizando otro servidor esclavo.</p>"},{"location":"Practica9/#cuestion-8-cuantos-servidores-raiz-existen","title":"Cuesti\u00f3n 8 \u00bfCu\u00e1ntos servidores ra\u00edz existen?","text":"<p>Existen 13 servidores ra\u00edz identificados por las letras de la \"A\" a la \"M\".</p>"},{"location":"Practica9/#cuestion-9-que-es-una-consulta-iterativa-de-referencia","title":"Cuesti\u00f3n 9 \u00bfQu\u00e9 es una consulta iterativa de referencia?","text":"<p>Una consulta iterativa de referencia es un tipo de consulta realizada en el sistema DNS para resolver un nombre de  dominio de manera eficiente, donde el cliente DNS  se comunica con varios servidores DNS de manera secuencial hasta</p> <p>obtener una respuesta final.</p>"},{"location":"Practica9/#cuestion-10-en-una-resolucion-inversa-a-que-nombre-se-mapearia-la-direccion-ip-172163456","title":"Cuesti\u00f3n 10 En una resoluci\u00f3n inversa, \u00bfa qu\u00e9 nombre se mapear\u00eda la direcci\u00f3n IP 172.16.34.56?","text":"<p>La direcci\u00f3n IP 172.16.34.56 se mapear\u00eda al nombre 56.34.16.172.in-addr.arpa.</p>"},{"location":"PracticaAmpliacion/","title":"PracticaAmpliacion","text":"<p>El objetivo de esta pr\u00e1ctica es configurar un servidor Nginx que utilice hosts virtuales para alojar m\u00faltiples sitios web en un solo servidor y que cada host virtual apunte al directorio <code>public_html</code> de distintos usuarios del sistema operativo Debian. De esta manera, cada usuario podr\u00e1 gestionar su propio sitio web desde su carpeta personal.</p>"},{"location":"PracticaAmpliacion/#instalacion-de-nginx","title":"Instalaci\u00f3n de Nginx","text":"<p>Para poder hacer esto necesitamos instalar Nginx. Si no est\u00e1 instalado, los pasos para hacerlo son:</p> <ol> <li> <p>Actualizamos el sistema con este comando:     <code>bash     sudo apt update &amp;&amp; sudo apt upgrade -y</code></p> </li> <li> <p>Instalamos Nginx con este comando:     <code>bash     sudo apt install nginx -y</code></p> </li> <li> <p>Verificamos si est\u00e1 activo con este comando:     <code>bash     sudo systemctl status nginx</code></p> <p>Deber\u00eda de salir esto si est\u00e1 funcionando:</p> </li> </ol> <p></p> <ol> <li>Si no est\u00e1 activo, lo activamos con este comando:     <code>bash     sudo systemctl start nginx</code></li> </ol> <p>Una vez hecho esto, Nginx deber\u00eda estar funcionando correctamente, por lo que ya podremos empezar con la creaci\u00f3n de los usuarios.</p>"},{"location":"PracticaAmpliacion/#creacion-de-usuarios","title":"Creaci\u00f3n de Usuarios","text":"<p>Para la creaci\u00f3n de los usuarios, en este caso dos de ellos, tendremos que usar los siguientes comandos:</p> <pre><code>sudo adduser usuario1\nsudo adduser usuario2\n</code></pre> <p>Una vez que hagamos esto, nos pedir\u00e1 que le asociemos una contrase\u00f1a a cada usuario nuevo que creemos. Adem\u00e1s de la contrase\u00f1a, tambi\u00e9n se le asociar\u00e1n m\u00e1s datos que para esta pr\u00e1ctica se pueden dejar en blanco, como n\u00famero de tel\u00e9fono...</p> <p></p>"},{"location":"PracticaAmpliacion/#creacion-de-directorios-public_html","title":"Creaci\u00f3n de Directorios <code>public_html</code>","text":"<p>Despu\u00e9s de esto, procedemos a crear las carpetas <code>public_html</code> en cada usuario. Para esto usaremos estos comandos:</p> <pre><code>sudo mkdir /home/usuario1/public_html\nsudo mkdir /home/usuario2/public_html\n</code></pre> <p></p> <p>Una vez hecho esto, le damos los permisos correspondientes. Para hacer esto usamos estos comandos:</p> <pre><code>sudo chmod 755 /home/usuario1/public_html\nsudo chmod 755 /home/usuario2/public_html\n</code></pre> <p>Despu\u00e9s, le cambiamos la propiedad de los directorios a sus respectivos usuarios con estos comandos:</p> <pre><code>sudo chown -R www-data:www-data /home/usuario1/public_html\nsudo chown -R www-data:www-data /home/usuario2/public_html\n</code></pre> <p></p>"},{"location":"PracticaAmpliacion/#creacion-del-contenido-web","title":"Creaci\u00f3n del Contenido Web","text":"<p>Ahora que ya hemos dado los permisos, ya podemos empezar con la creaci\u00f3n del contenido web.</p> <p>Para esto necesitamos crear en cada carpeta <code>public_html</code> de cada usuario un archivo <code>index.html</code> con un contenido para que se muestre.</p> <p>Podemos usar este como ejemplo para el usuario1:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n     &lt;title&gt;Usuario 1&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n     &lt;h1&gt;Bienvenido al sitio de Usuario 1&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Para el usuario2 podemos usar el mismo pero cambi\u00e1ndole el 1 por el 2.</p> <p>Para hacer esto, crearemos los <code>index.html</code> y le a\u00f1adiremos el contenido de ejemplo con:</p> <pre><code>sudo nano /home/usuario1/public_html/index.html\nsudo nano /home/usuario2/public_html/index.html\n</code></pre> <p>y le introducimos el HTML.</p> <p></p> <p></p>"},{"location":"PracticaAmpliacion/#configuracion-de-nginx","title":"Configuraci\u00f3n de Nginx","text":"<p>Una vez tenemos esto, ya podemos empezar con la configuraci\u00f3n de Nginx.</p> <p>Para empezar, nos vamos a dirigir a <code>/etc/nginx/sites-available/</code> y crearemos los archivos de configuraci\u00f3n para cada usuario.</p> <p>Como tenemos que hacer uno para cada usuario, voy a llamarlos <code>usuario1conf</code> y <code>usuario2conf</code>.</p> <p>Estos los crearemos usando <code>nano</code>, su contenido ser\u00e1 este:</p> <pre><code>server {\n     listen 80;\n     server_name usuario1.local;\n\n     root /home/usuario1/public_html;\n     index index.html;\n\n     location / {\n          try_files $uri $uri/ =404;\n     }\n}\n</code></pre> <p>En el se indica el puerto y la ruta que se deber\u00e1 de cambiar para el usuario 2.</p> <p></p> <p></p> <p>Ahora necesitamos habilitar los sitios web. Para ello necesitamos crear un enlace simb\u00f3lico para cada uno en <code>/etc/nginx/sites-enabled/</code>.</p> <p>Los crearemos con estos comandos:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/usuario1conf /etc/nginx/sites-enabled/\nsudo ln -s /etc/nginx/sites-available/usuario2conf /etc/nginx/sites-enabled/\n</code></pre> <p>Una vez hecho esto, al meternos en <code>sites-enabled</code> deber\u00eda verse as\u00ed:</p> <p></p> <p>Debe salir del mismo color que se muestra en la foto. Si no aparece de la misma forma, es porque ha habido alg\u00fan error.</p> <p>Una vez hecho esto, ponemos el siguiente comando para ver si tenemos alg\u00fan error:</p> <pre><code>sudo nginx -t\n</code></pre> <p>Y si todo sale bien, ponemos:</p> <pre><code>sudo systemctl reload nginx\n</code></pre> <p>para reiniciar Nginx.</p> <p></p>"},{"location":"PracticaAmpliacion/#configuracion-del-archivo-hosts","title":"Configuraci\u00f3n del Archivo <code>hosts</code>","text":"<p>Una vez hecho esto, tenemos que abrir el archivo <code>hosts</code> de nuestra m\u00e1quina f\u00edsica y poner lo siguiente:</p> <p></p> <p>Para que funcione, deber\u00e9is de poner la IP de vuestra m\u00e1quina virtual y el nombre del dominio que hab\u00e9is puesto en los archivos de configuraci\u00f3n:</p> <pre><code>http://usuario1.local\nhttp://usuario2.local\n</code></pre> <p>Una vez hecho esto, al acceder a las URL deber\u00eda de aparecer el contenido de los HTML de prueba que metimos en el directorio de <code>public_html</code>.</p> <p></p>"},{"location":"PracticaAmpliacion/#configuracion-https","title":"Configuraci\u00f3n HTTPS","text":"<p>Ahora, para terminar, lo que necesitamos es a\u00f1adir la configuraci\u00f3n HTTPS. Para ello, primero debemos generar los certificados SSL autofirmados para cada dominio:</p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/usuario1.key -out /etc/ssl/certs/usuario1.crt\nsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/usuario2.key -out /etc/ssl/certs/usuario2.crt\n</code></pre> <p></p> <p>El siguiente paso es modificar los archivos de configuraci\u00f3n para que incluya el HTTPS.</p> <p></p> <p>Despu\u00e9s de modificar los archivos, volvemos a reiniciar Nginx con:</p> <pre><code>sudo systemctl reload nginx\n</code></pre> <p>y ya deber\u00eda de aparecer el certificado.</p> <p></p>"}]}